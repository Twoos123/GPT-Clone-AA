import type { OAuth2Namespace, OAuth2Token as Token } from "@fastify/oauth2";
import oauth2 from "@fastify/oauth2";
import type { AnyClient, AnyModelManager } from "@gadgetinc/api-client-core";
import type { FastifyInstance, FastifyReply, FastifyRequest, HookHandlerDoneFunction } from "fastify";
import fp from "fastify-plugin";
import jwt from "jsonwebtoken";

const googleSignupTrigger = "gadget/trigger/google_oauth/signup";
const googleSigninTrigger = "gadget/trigger/google_oauth/signin";

declare module "fastify" {
  interface FastifyInstance {
    googleOAuth2: OAuth2Namespace;
    currentAppBridge: {
      areaConfig: AppConfig;
    };
  }

  interface FastifyReply {
    view: (page: string, data?: object) => Promise<string>;
  }

  interface FastifyRequest {
    gadgetAuth?: Partial<GadgetAuthOptions<any>>;
  }
}

export type Providers<UserInput> = {
  type: "google";
  /**
   * Your Google OAuth client id. This must be set when using `gadgetManagedCredentials: false`
   */
  clientId: string;
  /**
   * Your Google OAuth client secret. This must be set when using `gadgetManagedCredentials: false`
   */
  clientSecret: string;
  /**
   * An optional set of scopes to use in the OAuth request to google. If none are specified, will default to `["email", "profile"]`
   */
  scopes?: string[];
  /**
   * Configures the path to which the user is redirected after a successful Google OAuth sign in. Defaults to `/`.
   */
  redirectTo?: string;
  /**
   * If `true`, your plugins will use Gadget-managed credentials to avoid having to set up a OAuth client credentials in Google. This should
   * not be used in `production`.
   */
  gadgetManagedCredentials?: boolean;

  /**
   * Configure the relative path, which will be used in the `redirectURI` that is sent to Google. It will be relative to your environment's domain. This value is explicitly set in order to teach you about your internal auth paths, but should not be changed. Defaults to `/auth/google/callback` in your app's code.
   */
  callbackPath: string;
};

/**
 * Options for the Gadget auth plugin
 * @property {Providers} providers The providers to use for authentication
 * @property {AnyClient} api The Gadget API client to use for creating and updating users and sessions
 * @property {string} loginPath The path to redirect to when a route is protected and the user is not signed in. Defaults to `/login`.
 * @property {boolean} redirectToLogin Whether to redirect to the login path when a route is protected and the user is not signed in. Defaults to `false`.
 */
export type GadgetAuthOptions<UserInput> = {
  /**
   * If `true`, your plugins will use Gadget-managed credentials to avoid having to set up a OAuth clients on supported OAuth providers to start. This should
   * not be used in `production`. Can be overriden on a per-provider basis.
   */
  gadgetManagedCredentials?: boolean;
  /**
   * The oauth2 providers to use for authentication. Supported providers: `google`
   */
  providers: Providers<UserInput>[];
  /**
   * Your Gadget API client to use for creating and updating `User` and `Session` records. This should be the exported `api` client from the `gadget-server` package.
   */
  api: AnyClient;
  /**
   * The `signInPath` used when `redirectToSignIn` is set to `true`. Defaults to `/`.
   */
  signInPath?: string;
  /**
   * Configures whether to redirect to the `signInPath` when a route is protected and the `User` is not signed in, or simply to reply with a `403`. Defaults to `false`.
   */
  redirectToSignIn?: boolean;
  /**
   * Configures the path to which the user is redirected after a successful sign in on the oauth2 provider. Defaults to `/`.
   */
  redirectTo?: string;
};

type GoogleOAuthResult = {
  sub: string;
  name: string;
  given_name: string;
  family_name: string;
  picture: string;
  email: string;
  email_verified: string;
  locale: string;
  hd: string;
};

type AppConfig = {
  sessionModel?: {
    apiIdentifier: string;
    key: string;
  };
  userModel?: {
    apiIdentifier: string;
    key: string;
    [googleSigninTrigger]: {
      triggerAction: string;
      inputType: string;
    };
    [googleSignupTrigger]: {
      triggerAction: string;
      inputType: string;
    };
    updateAction: {
      apiIdentifier: string;
      triggerAction: string;
      inputType: string;
    };
  };
};

interface Session {
  id: string | null;
  get(key: string): any;
  set(key: string, value: any): void;
}

const getSessionFromRequest = <Request extends FastifyRequest>(request: Request): Session => {
  if ("applicationSession" in request) {
    return request.applicationSession as Session;
  }

  throw new Error("The request is not a Gadget server request");
};

/**
 * Default mapping of Google OAuth result to user input
 * @param result Claims from Google OAuth result
 * @returns User input for creating/updating a user with the default User model
 */
export const googleResultToUser = (result: GoogleOAuthResult) => ({
  email: String(result.email),
  firstName: String(result.given_name),
  lastName: String(result.family_name),
  googleImageUrl: String(result.picture),
});

/**
 * Utility function to wrap route handlers with protection from unauthenticated requests.
 *
 * @param handler The route handler to protect
 * @param {ProtectedRouteOptions} options Options for the protected route
 * @returns handler function that is wrapped with route protection
 *
 * @example
 * ```ts
 * // routes/GET-protected-route.js
 * const { preValidation } = require("@gadgetinc/auth");
 *
 * module.exports = async ({ request, reply }) => {
 *  await reply.send("this is a protected route");
 * }
 *
 * module.options = {
 *  preValidation,
 * }
 * ```
 */
export const preValidation = async <RouteContext extends FastifyRequest>(request: RouteContext, reply: FastifyReply) => {
  let authenticated = false;
  const applicationSession = getSessionFromRequest(request);
  authenticated = !!applicationSession.get("user");

  if (!authenticated) {
    if (request.gadgetAuth?.redirectToSignIn) {
      await reply.redirect(request.gadgetAuth.signInPath);
    } else {
      await reply.status(403).send();
    }
  }
};

interface BaseUserInput {
  email: string;
  firstName: string;
  lastName: string;
  googleImageUrl: string;
}

interface OAuthStatePayload {
  redirectTo: string;
}

/**
 * Fastify auth plugin for Gadget apps. This plugin will register route handlers for the specified providers and handle creating/updating users and sessions.
 * @param {FastifyInstance} fastify instance of fastify server
 * @param {GadgetAuthOptions} options options for the auth plugin
 * @param {HookHandlerDoneFunction} done hook handler done function when plugin is registered
 *
 * @example
 * ```ts
 * import { Auth } from "@gadgetinc/auth";
 * import { Client } from "@gadget-client/my-app";
 *
 * const api = new Client({
 *  authenticationMode: {
 *   apiKey: "my-api-key",
 *  }
 * });
 *
 * export default function(server) {
 *  server.register(Auth, {
 *   gadgetManagedCredentials: false,
 *   api,
 *   providers: [
 *    {
 *      type: "google",
 *      clientId: process.env.GOOGLE_CLIENT_ID,
 *      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
 *    }
 *   ],
 *  });
 * }
 * ```
 */
export const Auth = fp(
  <UserInput extends BaseUserInput>(fastify: FastifyInstance, options: GadgetAuthOptions<UserInput>, done: HookHandlerDoneFunction) => {
    if (options.providers.length > 0) {
      const googleProvider = options.providers[0];
      const config = fastify.currentAppBridge.areaConfig;

      if (googleProvider.type !== "google") {
        done(new Error("Provider type must be `google`"));
        return;
      }

      if (!config.userModel) {
        done(new Error("A user model must exist"));
        return;
      }

      const userManager = options.api[config.userModel.apiIdentifier] as AnyModelManager;

      if (!config.userModel[googleSignupTrigger]?.triggerAction) {
        done(new Error("User model must have a google signup trigger"));
        return;
      }

      if (!config.userModel[googleSigninTrigger]?.triggerAction) {
        done(new Error("User model must have google signin trigger"));
        return;
      }

      fastify.addHook("onRequest", (request: FastifyRequest, _reply: FastifyReply, done: HookHandlerDoneFunction) => {
        request.gadgetAuth = {
          redirectToSignIn: options.redirectToSignIn ?? false,
          signInPath: options.signInPath ?? "/",
        };
        done();
      });

      // api root urls aren't exposed on AnyClient. The type cast to any can be removed once we add the types
      const appUrl = new URL(
        process.env.NODE_ENV === "production" ? (options.api as any).productionApiRoot : (options.api as any).developmentApiRoot
      );

      const callbackPath = googleProvider.callbackPath ?? "/auth/google/callback";
      const gadgetManagedCredentials = googleProvider.gadgetManagedCredentials ?? options.gadgetManagedCredentials ?? false;
      const scope = googleProvider.scopes ?? ["email", "profile"];
      const redirectToPath = googleProvider.redirectTo ?? options.redirectTo ?? "/";
      const redirectTo = new URL(redirectToPath, appUrl).toString();

      fastify.get(callbackPath, async function <
        RouteContext extends FastifyRequest<{ Querystring: { state: string } }>
      >(this: FastifyInstance, request: RouteContext, reply: FastifyReply) {
        const token: Token & { id_token?: string } = await this.googleOAuth2.getAccessTokenFromAuthorizationCodeFlow(request);

        if (!token.id_token) {
          await reply.status(400).send();
          return;
        }

        const decoded = jwt.decode(token.id_token) as GoogleOAuthResult | null;
        // there are additional properties in the decoded json blob that we want to ignore
        const user: GoogleOAuthResult = {
          sub: decoded.sub,
          name: decoded.name,
          given_name: decoded.given_name,
          family_name: decoded.family_name,
          picture: decoded.picture,
          email: decoded.email,
          email_verified: decoded.email_verified,
          locale: decoded.locale,
          hd: decoded.hd,
        };

        if (!decoded) {
          await reply.status(400).send();
          return;
        }

        let claims: GoogleOAuthResult;

        if (typeof decoded === "string") {
          claims = JSON.parse(decoded);
        } else {
          claims = decoded;
        }

        const userRecord = await userManager.maybeFindFirst({
          filter: {
            email: {
              equals: claims.email,
            },
          },
        });

        const applicationSession = getSessionFromRequest(request);
        await createSessionIfNotPersisted(applicationSession, options.api);

        if (userRecord) {
          const existingUserId = userRecord.getField("id");
          const userInput = googleResultToUser(claims);
          delete userInput.email;

          const result = await options.api.mutate(
            `
              mutation TriggerSignInUser($params: JSONObject, $trigger: JSONObject, $verify: Boolean, $context: AppGraphQLTriggerMutationContext) {
                internal {
                  ${config.userModel[googleSigninTrigger].triggerAction}(params: $params, trigger: $trigger, verifyTriggerExists: $verify, context: $context) {
                    success
                    errors {
                      message
                      code
                    }
                  }
                }
              }
            `,
            {
              params: {
                [config.userModel.apiIdentifier]: userInput,
                id: existingUserId,
              },
              trigger: {
                type: "google_oauth_signin",
              },
              context: {
                sessionID: applicationSession?.id,
              },
              verify: true,
            }
          );

          if (!result.internal[config.userModel[googleSigninTrigger].triggerAction].success) {
            await reply.status(500).send({ errors: result.internal[config.userModel[googleSigninTrigger].triggerAction]?.errors });
            return;
          }

          if (userNeedsUpdate(userRecord, claims)) {
            const updateResult = await options.api.mutate(
              `
            mutation TriggerUpdateUser($params: JSONObject, $trigger: JSONObject, $verify: Boolean, $context: AppGraphQLTriggerMutationContext) {
              internal {
                ${config.userModel.updateAction.triggerAction}(params: $params, trigger: $trigger, verifyTriggerExists: $verify, context: $context) {
                  success
                  errors {
                    message
                    code
                  }
                }
              }
            }`,

              {
                params: {
                  [config.userModel.apiIdentifier]: userInput,
                  id: userRecord.id,
                },
                trigger: {
                  type: "api",
                  mutationName: config.userModel.updateAction.apiIdentifier,
                  rootModel: config.userModel.apiIdentifier,
                  rootAction: config.userModel.updateAction.apiIdentifier,
                  rawParams: userInput,
                },
                context: {
                  sessionID: applicationSession?.id,
                },
                verify: true,
              }
            );

            if (!updateResult.internal[config.userModel.updateAction.triggerAction].success) {
              await reply.status(500).send({ errors: updateResult.internal[config.userModel.updateAction.triggerAction].errors });
              return;
            }
          }
        } else {
          const result = await options.api.mutate(
            `
              mutation TriggerSignUpUser($params: JSONObject, $trigger: JSONObject, $verify: Boolean, $context: AppGraphQLTriggerMutationContext) {
                internal {
                  ${config.userModel[googleSignupTrigger].triggerAction}(params: $params, trigger: $trigger, verifyTriggerExists: $verify, context: $context) {
                    success
                    errors {
                      message
                      code
                    }
                    ${config.userModel.apiIdentifier} {
                      id
                    }
                  }
                }
              }
            `,
            {
              params: {
                [config.userModel.apiIdentifier]: googleResultToUser(claims),
              },
              trigger: {
                type: "google_oauth_signup",
                user,
              },
              context: {
                sessionID: applicationSession?.id,
              },
              verify: true,
            }
          );

          if (!result.internal[config.userModel[googleSignupTrigger].triggerAction]?.success) {
            await reply.status(500).send({ errors: result.internal[config.userModel[googleSignupTrigger].triggerAction]?.errors });
            return;
          }
        }

        // this is verified in the checkStateFunction option provided to the oauth2Google provider
        const { redirectTo: searchRedirectTo } = jwt.decode(request.query.state) as OAuthStatePayload;
        await reply.redirect(searchRedirectTo ?? redirectTo);
      });

      if (gadgetManagedCredentials) {
        fastify.get(
          "/auth/google/start",
          async (request: FastifyRequest<{ Querystring: { redirectTo?: string } }>, reply: FastifyReply) => {
            const { redirectTo: queryRedirectTo } = request.query;

            const redirectURL = new URL(`/api/auth/google/gadget/start`, appUrl);
            redirectURL.searchParams.set("scope", scope.join(" "));
            redirectURL.searchParams.set("redirectTo", queryRedirectTo ?? redirectToPath);
            await reply.redirect(redirectURL.toString());
          }
        );
        done();
      } else {
        if (!googleProvider.clientId || !googleProvider.clientSecret) {
          fastify.get("/auth/google/start", async (_request: FastifyRequest, reply: FastifyReply) => {
            void reply.header("Content-Type", "text/html");
            await reply.status(400).send(`
        <!DOCTYPE html>
        <html>
          <head>
            <link rel="preconnect" href="https://fonts.googleapis.com">
            <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
            <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@700&family=Inter:wght@400;700&display=swap" rel="stylesheet">
            <title>Google OAuth2 Error</title>
            <style>
              body {
                height: 100vh;
                width: 100vw;
                font-family: Inter, sans-serif;
                margin: 0;
              }
              .error-wrapper {
                display: flex;
                flex-direction: column;
                gap: 32px;
                padding: 64px;
                height: 100%;
                align-items: center;
                justify-content: center;
                box-sizing: border-box;
              }
              code {
                background-color: #EEEEEE;
                padding: 4px 8px;
                border-radius: 4px;
                font-weight: 700;
                font-family: Inconsolata, monospace;
                margin: 0 5px;
              }
              a {
                text-decoration: underline;
                color: black;
              }
              .error-wrapper h2 {
                text-align: center;
                margin: 0;
              }
              .error-wrapper .content {
                text-align: center;
                max-width: 500px;
                line-height: 25px;
              }
            </style>
          </head>
          <body>
            <div class="error-wrapper">
              <svg width="64" height="64" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M9.99992 2C9.44554 2 8.97063 2.33782 8.76945 2.81901L1.53377 15.2982V15.2995C1.40319 15.5098 1.33375 15.7524 1.33325 16C1.33325 16.3536 1.47373 16.6928 1.72378 16.9428C1.97382 17.1929 2.31296 17.3333 2.66659 17.3333C2.69787 17.3331 2.72914 17.3318 2.76034 17.3294L2.76294 17.3333H9.99992H17.2369L17.2395 17.3281C17.2707 17.331 17.3019 17.3327 17.3333 17.3333C17.6869 17.3333 18.026 17.1929 18.2761 16.9428C18.5261 16.6928 18.6666 16.3536 18.6666 16C18.6663 15.752 18.5969 15.5089 18.4661 15.2982L18.4556 15.2799C18.4552 15.2795 18.4548 15.2791 18.4543 15.2786L11.2304 2.81901C11.0292 2.33782 10.5543 2 9.99992 2ZM9.19132 7.57292H10.8085L10.6744 11.888H9.32544L9.19132 7.57292ZM10.0025 13.207C10.5505 13.207 10.8788 13.5019 10.8788 14.0052C10.8788 14.4992 10.5505 14.793 10.0025 14.793C9.45052 14.793 9.11971 14.4992 9.11971 14.0052C9.11971 13.5019 9.44986 13.207 10.0025 13.207Z"
                />
              </svg>
              <h2>Google OAuth2 credentials are not configured.</h2>
              <div class="content">
                Set up your <code>GOOGLE_CLIENT_ID</code> and <code>GOOGLE_CLIENT_SECRET</code><br>
                in the <a href="/edit/settings/env">environment variables</a> of your app, then try again.
              </div>
            </div>
          </body>
        </html>
        `);
          });

          done();
        } else {
          oauth2(
            fastify,
            {
              name: "googleOAuth2",
              scope,
              credentials: {
                client: {
                  id: googleProvider.clientId,
                  secret: googleProvider.clientSecret,
                },
                auth: oauth2.GOOGLE_CONFIGURATION,
              },
              callbackUri: `${appUrl.origin}/auth/google/callback`,
              startRedirectPath: "/auth/google/start",
              generateStateFunction: (request) => {
                const finalRedirectTo = new URL(request.query.redirectTo ?? redirectTo, appUrl).toString();
                const payload: OAuthStatePayload = { redirectTo: finalRedirectTo };
                return jwt.sign(payload, googleProvider.clientSecret, { expiresIn: "1h" });
              },
              checkStateFunction: (state, callback) => {
                try {
                  jwt.verify(state, googleProvider.clientSecret);
                  callback();
                } catch (error) {
                  callback(error);
                }
              },
            },
            done
          );
        }
      }
    }
  },
  {
    fastify: "3.x",
  }
);

const userNeedsUpdate = (userRecord: any, googleUser: GoogleOAuthResult) => {
  return (
    userRecord.firstName !== googleUser.given_name ||
    userRecord.lastName !== googleUser.family_name ||
    userRecord.googleImageUrl !== googleUser.picture
  );
};

const createSessionIfNotPersisted = async (session: Session, api: AnyClient) => {
  if (!session.id) {
    const { id } = await (api as any).internal.session.create({});
    session.id = id;
  }
};
