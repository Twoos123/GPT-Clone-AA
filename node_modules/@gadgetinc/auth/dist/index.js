"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Auth = exports.preValidation = exports.googleResultToUser = void 0;
const oauth2_1 = __importDefault(require("@fastify/oauth2"));
const fastify_plugin_1 = __importDefault(require("fastify-plugin"));
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const googleSignupTrigger = "gadget/trigger/google_oauth/signup";
const googleSigninTrigger = "gadget/trigger/google_oauth/signin";
const getSessionFromRequest = (request) => {
    if ("applicationSession" in request) {
        return request.applicationSession;
    }
    throw new Error("The request is not a Gadget server request");
};
/**
 * Default mapping of Google OAuth result to user input
 * @param result Claims from Google OAuth result
 * @returns User input for creating/updating a user with the default User model
 */
const googleResultToUser = (result) => ({
    email: String(result.email),
    firstName: String(result.given_name),
    lastName: String(result.family_name),
    googleImageUrl: String(result.picture),
});
exports.googleResultToUser = googleResultToUser;
/**
 * Utility function to wrap route handlers with protection from unauthenticated requests.
 *
 * @param handler The route handler to protect
 * @param {ProtectedRouteOptions} options Options for the protected route
 * @returns handler function that is wrapped with route protection
 *
 * @example
 * ```ts
 * // routes/GET-protected-route.js
 * const { preValidation } = require("@gadgetinc/auth");
 *
 * module.exports = async ({ request, reply }) => {
 *  await reply.send("this is a protected route");
 * }
 *
 * module.options = {
 *  preValidation,
 * }
 * ```
 */
const preValidation = async (request, reply) => {
    let authenticated = false;
    const applicationSession = getSessionFromRequest(request);
    authenticated = !!applicationSession.get("user");
    if (!authenticated) {
        if (request.gadgetAuth?.redirectToSignIn) {
            await reply.redirect(request.gadgetAuth.signInPath);
        }
        else {
            await reply.status(403).send();
        }
    }
};
exports.preValidation = preValidation;
/**
 * Fastify auth plugin for Gadget apps. This plugin will register route handlers for the specified providers and handle creating/updating users and sessions.
 * @param {FastifyInstance} fastify instance of fastify server
 * @param {GadgetAuthOptions} options options for the auth plugin
 * @param {HookHandlerDoneFunction} done hook handler done function when plugin is registered
 *
 * @example
 * ```ts
 * import { Auth } from "@gadgetinc/auth";
 * import { Client } from "@gadget-client/my-app";
 *
 * const api = new Client({
 *  authenticationMode: {
 *   apiKey: "my-api-key",
 *  }
 * });
 *
 * export default function(server) {
 *  server.register(Auth, {
 *   gadgetManagedCredentials: false,
 *   api,
 *   providers: [
 *    {
 *      type: "google",
 *      clientId: process.env.GOOGLE_CLIENT_ID,
 *      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
 *    }
 *   ],
 *  });
 * }
 * ```
 */
exports.Auth = (0, fastify_plugin_1.default)((fastify, options, done) => {
    if (options.providers.length > 0) {
        const googleProvider = options.providers[0];
        const config = fastify.currentAppBridge.areaConfig;
        if (googleProvider.type !== "google") {
            done(new Error("Provider type must be `google`"));
            return;
        }
        if (!config.userModel) {
            done(new Error("A user model must exist"));
            return;
        }
        const userManager = options.api[config.userModel.apiIdentifier];
        if (!config.userModel[googleSignupTrigger]?.triggerAction) {
            done(new Error("User model must have a google signup trigger"));
            return;
        }
        if (!config.userModel[googleSigninTrigger]?.triggerAction) {
            done(new Error("User model must have google signin trigger"));
            return;
        }
        fastify.addHook("onRequest", (request, _reply, done) => {
            request.gadgetAuth = {
                redirectToSignIn: options.redirectToSignIn ?? false,
                signInPath: options.signInPath ?? "/",
            };
            done();
        });
        // api root urls aren't exposed on AnyClient. The type cast to any can be removed once we add the types
        const appUrl = new URL(process.env.NODE_ENV === "production" ? options.api.productionApiRoot : options.api.developmentApiRoot);
        const callbackPath = googleProvider.callbackPath ?? "/auth/google/callback";
        const gadgetManagedCredentials = googleProvider.gadgetManagedCredentials ?? options.gadgetManagedCredentials ?? false;
        const scope = googleProvider.scopes ?? ["email", "profile"];
        const redirectToPath = googleProvider.redirectTo ?? options.redirectTo ?? "/";
        const redirectTo = new URL(redirectToPath, appUrl).toString();
        fastify.get(callbackPath, async function (request, reply) {
            const token = await this.googleOAuth2.getAccessTokenFromAuthorizationCodeFlow(request);
            if (!token.id_token) {
                await reply.status(400).send();
                return;
            }
            const decoded = jsonwebtoken_1.default.decode(token.id_token);
            // there are additional properties in the decoded json blob that we want to ignore
            const user = {
                sub: decoded.sub,
                name: decoded.name,
                given_name: decoded.given_name,
                family_name: decoded.family_name,
                picture: decoded.picture,
                email: decoded.email,
                email_verified: decoded.email_verified,
                locale: decoded.locale,
                hd: decoded.hd,
            };
            if (!decoded) {
                await reply.status(400).send();
                return;
            }
            let claims;
            if (typeof decoded === "string") {
                claims = JSON.parse(decoded);
            }
            else {
                claims = decoded;
            }
            const userRecord = await userManager.maybeFindFirst({
                filter: {
                    email: {
                        equals: claims.email,
                    },
                },
            });
            const applicationSession = getSessionFromRequest(request);
            await createSessionIfNotPersisted(applicationSession, options.api);
            if (userRecord) {
                const existingUserId = userRecord.getField("id");
                const userInput = (0, exports.googleResultToUser)(claims);
                delete userInput.email;
                const result = await options.api.mutate(`
              mutation TriggerSignInUser($params: JSONObject, $trigger: JSONObject, $verify: Boolean, $context: AppGraphQLTriggerMutationContext) {
                internal {
                  ${config.userModel[googleSigninTrigger].triggerAction}(params: $params, trigger: $trigger, verifyTriggerExists: $verify, context: $context) {
                    success
                    errors {
                      message
                      code
                    }
                  }
                }
              }
            `, {
                    params: {
                        [config.userModel.apiIdentifier]: userInput,
                        id: existingUserId,
                    },
                    trigger: {
                        type: "google_oauth_signin",
                    },
                    context: {
                        sessionID: applicationSession?.id,
                    },
                    verify: true,
                });
                if (!result.internal[config.userModel[googleSigninTrigger].triggerAction].success) {
                    await reply.status(500).send({ errors: result.internal[config.userModel[googleSigninTrigger].triggerAction]?.errors });
                    return;
                }
                if (userNeedsUpdate(userRecord, claims)) {
                    const updateResult = await options.api.mutate(`
            mutation TriggerUpdateUser($params: JSONObject, $trigger: JSONObject, $verify: Boolean, $context: AppGraphQLTriggerMutationContext) {
              internal {
                ${config.userModel.updateAction.triggerAction}(params: $params, trigger: $trigger, verifyTriggerExists: $verify, context: $context) {
                  success
                  errors {
                    message
                    code
                  }
                }
              }
            }`, {
                        params: {
                            [config.userModel.apiIdentifier]: userInput,
                            id: userRecord.id,
                        },
                        trigger: {
                            type: "api",
                            mutationName: config.userModel.updateAction.apiIdentifier,
                            rootModel: config.userModel.apiIdentifier,
                            rootAction: config.userModel.updateAction.apiIdentifier,
                            rawParams: userInput,
                        },
                        context: {
                            sessionID: applicationSession?.id,
                        },
                        verify: true,
                    });
                    if (!updateResult.internal[config.userModel.updateAction.triggerAction].success) {
                        await reply.status(500).send({ errors: updateResult.internal[config.userModel.updateAction.triggerAction].errors });
                        return;
                    }
                }
            }
            else {
                const result = await options.api.mutate(`
              mutation TriggerSignUpUser($params: JSONObject, $trigger: JSONObject, $verify: Boolean, $context: AppGraphQLTriggerMutationContext) {
                internal {
                  ${config.userModel[googleSignupTrigger].triggerAction}(params: $params, trigger: $trigger, verifyTriggerExists: $verify, context: $context) {
                    success
                    errors {
                      message
                      code
                    }
                    ${config.userModel.apiIdentifier} {
                      id
                    }
                  }
                }
              }
            `, {
                    params: {
                        [config.userModel.apiIdentifier]: (0, exports.googleResultToUser)(claims),
                    },
                    trigger: {
                        type: "google_oauth_signup",
                        user,
                    },
                    context: {
                        sessionID: applicationSession?.id,
                    },
                    verify: true,
                });
                if (!result.internal[config.userModel[googleSignupTrigger].triggerAction]?.success) {
                    await reply.status(500).send({ errors: result.internal[config.userModel[googleSignupTrigger].triggerAction]?.errors });
                    return;
                }
            }
            // this is verified in the checkStateFunction option provided to the oauth2Google provider
            const { redirectTo: searchRedirectTo } = jsonwebtoken_1.default.decode(request.query.state);
            await reply.redirect(searchRedirectTo ?? redirectTo);
        });
        if (gadgetManagedCredentials) {
            fastify.get("/auth/google/start", async (request, reply) => {
                const { redirectTo: queryRedirectTo } = request.query;
                const redirectURL = new URL(`/api/auth/google/gadget/start`, appUrl);
                redirectURL.searchParams.set("scope", scope.join(" "));
                redirectURL.searchParams.set("redirectTo", queryRedirectTo ?? redirectToPath);
                await reply.redirect(redirectURL.toString());
            });
            done();
        }
        else {
            if (!googleProvider.clientId || !googleProvider.clientSecret) {
                fastify.get("/auth/google/start", async (_request, reply) => {
                    void reply.header("Content-Type", "text/html");
                    await reply.status(400).send(`
        <!DOCTYPE html>
        <html>
          <head>
            <link rel="preconnect" href="https://fonts.googleapis.com">
            <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
            <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@700&family=Inter:wght@400;700&display=swap" rel="stylesheet">
            <title>Google OAuth2 Error</title>
            <style>
              body {
                height: 100vh;
                width: 100vw;
                font-family: Inter, sans-serif;
                margin: 0;
              }
              .error-wrapper {
                display: flex;
                flex-direction: column;
                gap: 32px;
                padding: 64px;
                height: 100%;
                align-items: center;
                justify-content: center;
                box-sizing: border-box;
              }
              code {
                background-color: #EEEEEE;
                padding: 4px 8px;
                border-radius: 4px;
                font-weight: 700;
                font-family: Inconsolata, monospace;
                margin: 0 5px;
              }
              a {
                text-decoration: underline;
                color: black;
              }
              .error-wrapper h2 {
                text-align: center;
                margin: 0;
              }
              .error-wrapper .content {
                text-align: center;
                max-width: 500px;
                line-height: 25px;
              }
            </style>
          </head>
          <body>
            <div class="error-wrapper">
              <svg width="64" height="64" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M9.99992 2C9.44554 2 8.97063 2.33782 8.76945 2.81901L1.53377 15.2982V15.2995C1.40319 15.5098 1.33375 15.7524 1.33325 16C1.33325 16.3536 1.47373 16.6928 1.72378 16.9428C1.97382 17.1929 2.31296 17.3333 2.66659 17.3333C2.69787 17.3331 2.72914 17.3318 2.76034 17.3294L2.76294 17.3333H9.99992H17.2369L17.2395 17.3281C17.2707 17.331 17.3019 17.3327 17.3333 17.3333C17.6869 17.3333 18.026 17.1929 18.2761 16.9428C18.5261 16.6928 18.6666 16.3536 18.6666 16C18.6663 15.752 18.5969 15.5089 18.4661 15.2982L18.4556 15.2799C18.4552 15.2795 18.4548 15.2791 18.4543 15.2786L11.2304 2.81901C11.0292 2.33782 10.5543 2 9.99992 2ZM9.19132 7.57292H10.8085L10.6744 11.888H9.32544L9.19132 7.57292ZM10.0025 13.207C10.5505 13.207 10.8788 13.5019 10.8788 14.0052C10.8788 14.4992 10.5505 14.793 10.0025 14.793C9.45052 14.793 9.11971 14.4992 9.11971 14.0052C9.11971 13.5019 9.44986 13.207 10.0025 13.207Z"
                />
              </svg>
              <h2>Google OAuth2 credentials are not configured.</h2>
              <div class="content">
                Set up your <code>GOOGLE_CLIENT_ID</code> and <code>GOOGLE_CLIENT_SECRET</code><br>
                in the <a href="/edit/settings/env">environment variables</a> of your app, then try again.
              </div>
            </div>
          </body>
        </html>
        `);
                });
                done();
            }
            else {
                (0, oauth2_1.default)(fastify, {
                    name: "googleOAuth2",
                    scope,
                    credentials: {
                        client: {
                            id: googleProvider.clientId,
                            secret: googleProvider.clientSecret,
                        },
                        auth: oauth2_1.default.GOOGLE_CONFIGURATION,
                    },
                    callbackUri: `${appUrl.origin}/auth/google/callback`,
                    startRedirectPath: "/auth/google/start",
                    generateStateFunction: (request) => {
                        const finalRedirectTo = new URL(request.query.redirectTo ?? redirectTo, appUrl).toString();
                        const payload = { redirectTo: finalRedirectTo };
                        return jsonwebtoken_1.default.sign(payload, googleProvider.clientSecret, { expiresIn: "1h" });
                    },
                    checkStateFunction: (state, callback) => {
                        try {
                            jsonwebtoken_1.default.verify(state, googleProvider.clientSecret);
                            callback();
                        }
                        catch (error) {
                            callback(error);
                        }
                    },
                }, done);
            }
        }
    }
}, {
    fastify: "3.x",
});
const userNeedsUpdate = (userRecord, googleUser) => {
    return (userRecord.firstName !== googleUser.given_name ||
        userRecord.lastName !== googleUser.family_name ||
        userRecord.googleImageUrl !== googleUser.picture);
};
const createSessionIfNotPersisted = async (session, api) => {
    if (!session.id) {
        const { id } = await api.internal.session.create({});
        session.id = id;
    }
};
//# sourceMappingURL=index.js.map