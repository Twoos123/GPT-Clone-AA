{
  "version": 3,
  "sources": ["../src/builder.ts"],
  "sourcesContent": ["import type {\n  ActionFunctionMetadata,\n  AnyActionFunction,\n  AnyModelFinderMetadata,\n  AnyModelManager,\n  BaseFindOptions,\n  FieldSelection,\n  FindManyOptions,\n  GadgetConnection,\n  GadgetRecord,\n  VariablesOptions,\n} from \"@gadgetinc/api-client-core\";\nimport { actionRunner, findManyRunner, findOneByFieldRunner, findOneRunner, globalActionRunner } from \"@gadgetinc/api-client-core\";\n\n/**\n * The metadata that we need for building the runtime version of a finderoperation\n * Excludes the type-time only keys\n */\nexport type AnyModelFinderRuntimeMetadata = Omit<AnyModelFinderMetadata, \"schemaType\" | \"optionsType\" | \"variablesType\" | \"selectionType\">;\n\n/**\n * The metadata that we need for building the runtime version of a finder operation\n * Excludes the type-time only keys\n */\nexport type AnyActionFunctionRuntimeMetadata = Omit<\n  ActionFunctionMetadata<any, any, any, any, any, any>,\n  \"schemaType\" | \"optionsType\" | \"variablesType\" | \"selectionType\"\n>;\n\nexport type FindOneOperation = {\n  type: \"findOne\";\n  findByVariableName: \"id\";\n} & AnyModelFinderRuntimeMetadata;\n\nexport type MaybeFindOneOperation = {\n  type: \"maybeFindOne\";\n  findByVariableName: \"id\";\n} & AnyModelFinderRuntimeMetadata;\n\nexport type FindManyOperation = {\n  type: \"findMany\";\n} & AnyModelFinderRuntimeMetadata;\n\nexport type FindFirstOperation = {\n  type: \"findFirst\";\n} & AnyModelFinderRuntimeMetadata;\n\nexport type MaybeFindFirstOperation = {\n  type: \"maybeFindFirst\";\n} & AnyModelFinderRuntimeMetadata;\n\nexport type FindOneByFieldOperation = {\n  type: \"findOne\";\n  findByVariableName: string;\n  findByField: string;\n  functionName: string;\n} & AnyModelFinderRuntimeMetadata;\n\nexport type MaybeFindOneByFieldOperation = {\n  type: \"maybeFindOne\";\n  findByVariableName: string;\n  findByField: string;\n  functionName: string;\n} & AnyModelFinderRuntimeMetadata;\n\nexport type SingletonGetOperation = {\n  type: \"get\";\n} & AnyModelFinderRuntimeMetadata;\n\nexport type ActionOperation = {\n  type: \"action\";\n  functionName: string;\n  isBulk: false;\n  isDeleter: boolean;\n} & AnyActionFunctionRuntimeMetadata;\n\nexport type BulkActionOperation = {\n  type: \"action\";\n  functionName: string;\n  isBulk: true;\n  singleActionFunctionName: string;\n  isDeleter: boolean;\n} & AnyActionFunctionRuntimeMetadata;\n\nexport type GlobalActionOperation = {\n  type: \"globalAction\";\n  functionName: string;\n  operationName: string;\n  namespace: string | string[] | null;\n  variables: VariablesOptions;\n};\n\nexport type StubbedActionOperation = {\n  type: \"stubbedAction\";\n  functionName: string;\n  operationName?: string;\n  errorMessage: string;\n  modelApiIdentifier?: string;\n};\n\nexport type ModelManagerOperation =\n  | FindOneOperation\n  | MaybeFindOneOperation\n  | FindManyOperation\n  | FindFirstOperation\n  | MaybeFindFirstOperation\n  | FindOneByFieldOperation\n  | MaybeFindOneByFieldOperation\n  | SingletonGetOperation\n  | ActionOperation\n  | BulkActionOperation\n  | StubbedActionOperation;\n\n/**\n * Construct a model manager class out of the metadatas generated on the server\n **/\nexport const buildModelManager = (\n  apiIdentifier: string,\n  pluralApiIdentifier: string,\n  defaultSelection: FieldSelection,\n  operationGroup: ModelManagerOperation[] | readonly ModelManagerOperation[]\n): AnyModelManager => {\n  const modelManagerClass = class {\n    constructor(public readonly connection: GadgetConnection) {}\n  } as unknown as { prototype: AnyModelManager; new (connection: GadgetConnection): AnyModelManager };\n  Object.defineProperty(modelManagerClass, \"name\", { value: `${apiIdentifier}Manager` });\n\n  for (const operation of operationGroup) {\n    switch (operation.type) {\n      case \"maybeFindOne\":\n      case \"findOne\": {\n        const throwOnRecordNotFound = !operation.type.startsWith(\"maybe\");\n\n        if (\"functionName\" in operation) {\n          (modelManagerClass.prototype as any)[operation.functionName] = Object.assign(function (\n            this: AnyModelManager,\n            value: string,\n            options?: BaseFindOptions\n          ) {\n            return findOneByFieldRunner(\n              this,\n              operation.operationName,\n              operation.findByField,\n              value,\n              defaultSelection,\n              apiIdentifier,\n\n              options,\n              throwOnRecordNotFound,\n              operation.namespace\n            );\n          },\n          operation as unknown as AnyModelFinderMetadata);\n        } else {\n          modelManagerClass.prototype[operation.type] = Object.assign(function (\n            this: AnyModelManager,\n            id: string,\n            options?: BaseFindOptions\n          ) {\n            const response = findOneRunner(\n              this,\n              apiIdentifier,\n              id,\n              defaultSelection,\n              apiIdentifier,\n              options,\n              throwOnRecordNotFound,\n              operation.namespace\n            );\n            return forEachMaybeLiveResponse(response, (record: GadgetRecord<any>) => (record.isEmpty() ? null : record));\n          },\n          operation as unknown as AnyModelFinderMetadata);\n        }\n        break;\n      }\n\n      case \"findMany\": {\n        modelManagerClass.prototype.findMany = Object.assign(function (this: AnyModelManager, options?: FindManyOptions) {\n          return findManyRunner(this, pluralApiIdentifier, defaultSelection, apiIdentifier, options, undefined, operation.namespace);\n        }, operation as unknown as AnyModelFinderMetadata);\n        break;\n      }\n      case \"maybeFindFirst\":\n      case \"findFirst\": {\n        modelManagerClass.prototype[operation.type] = Object.assign(function (this: AnyModelManager, options?: BaseFindOptions) {\n          const response = findManyRunner(\n            this,\n            pluralApiIdentifier,\n            defaultSelection,\n            apiIdentifier,\n            {\n              ...options,\n              first: 1,\n              last: undefined,\n              before: undefined,\n              after: undefined,\n            },\n            operation.type != \"maybeFindFirst\",\n            operation.namespace\n          );\n          return forEachMaybeLiveResponse(response, (list: GadgetRecord<any>[]) => list?.[0] ?? null);\n        }, operation as unknown as AnyModelFinderMetadata);\n        break;\n      }\n\n      case \"get\": {\n        (modelManagerClass.prototype as any).get = Object.assign(function (this: AnyModelManager, options?: BaseFindOptions) {\n          return findOneRunner(\n            this,\n            operation.operationName,\n            undefined,\n            defaultSelection,\n            apiIdentifier,\n            options,\n            undefined,\n            operation.namespace\n          );\n        }, operation as unknown as AnyModelFinderMetadata);\n        break;\n      }\n      case \"action\": {\n        if (operation.isBulk) {\n          const bulkInvokedByIDOnly = !!operation.variables[\"ids\"];\n\n          (modelManagerClass.prototype as any)[operation.functionName] = Object.assign(async function (\n            this: AnyModelManager,\n            inputs: string[] | Record<string, unknown>[],\n            options?: BaseFindOptions\n          ) {\n            let variables;\n            if (bulkInvokedByIDOnly) {\n              variables = {\n                ids: {\n                  ...operation.variables[\"ids\"],\n                  value: inputs,\n                },\n              };\n            } else {\n              variables = {\n                inputs: {\n                  ...operation.variables[\"inputs\"],\n                  value: (inputs as Record<string, unknown>[]).map((input) =>\n                    disambiguateActionParams((this as any)[(operation as BulkActionOperation).singleActionFunctionName], undefined, input)\n                  ),\n                },\n              };\n            }\n\n            return await actionRunner(\n              this,\n              operation.operationName,\n              operation.isDeleter ? null : defaultSelection,\n              apiIdentifier,\n              operation.modelSelectionField,\n              true,\n              variables,\n              options,\n              operation.namespace,\n              operation.hasReturnType as any\n            );\n          },\n          operation as unknown as AnyModelFinderMetadata);\n        } else {\n          const hasId = !!operation.variables[\"id\"];\n          const hasOthers = Object.keys(operation.variables).filter((key) => key != \"id\").length > 0;\n          (modelManagerClass.prototype as any)[operation.functionName] = Object.assign(async function (\n            this: AnyModelManager,\n            ...args: (string | Record<string, unknown> | BaseFindOptions)[]\n          ) {\n            const [variables, options] = actionArgs(operation, hasId, hasOthers, args);\n\n            return await actionRunner(\n              this,\n              operation.operationName,\n              operation.isDeleter ? null : defaultSelection,\n              apiIdentifier,\n              operation.modelSelectionField,\n              false,\n              variables,\n              options,\n              operation.namespace,\n              operation.hasReturnType as any\n            );\n          },\n          operation as unknown as AnyModelFinderMetadata);\n        }\n        break;\n      }\n      case \"stubbedAction\": {\n        (modelManagerClass.prototype as any)[operation.functionName] = Object.assign(function (this: AnyModelManager, ..._args: any) {\n          throw new Error(operation.errorMessage);\n        }, operation as unknown as AnyModelFinderMetadata);\n        break;\n      }\n    }\n  }\n\n  return modelManagerClass as any;\n};\n\nexport const buildGlobalAction = (\n  client: { connection: GadgetConnection },\n  operation: GlobalActionOperation | StubbedActionOperation\n): AnyActionFunction => {\n  if (operation.type == \"stubbedAction\") {\n    return Object.assign((..._args: any[]) => {\n      throw new Error(operation.errorMessage);\n    }, operation) as any;\n  } else {\n    return Object.assign(async (variables: Record<string, any> = {}) => {\n      const resultVariables: VariablesOptions = {};\n      for (const [name, variable] of Object.entries(operation.variables)) {\n        resultVariables[name] = {\n          value: variables[name],\n          ...variable,\n        };\n      }\n\n      return await globalActionRunner(client.connection, operation.operationName, resultVariables, operation.namespace);\n    }, operation) as any;\n  }\n};\n\n/**\n * Maps the variables passed from a call to the client to the variables the GraphQL API is expecting\n *\n * For actions which accept a model input, the GraphQL API expects the variables to be passed like\n *  id: 123,\n *  widget: { fieldA: \"a\", fieldB: \"b\" },\n *  extraParam: \"C\"\n *\n * For convenience, we allow actions to be invoked like\n *   await api.widget.update(\"123\", {fieldA: \"a\", fieldB: \"b\", extraParam: \"C\"})\n *\n * This function re-nests the model input variables under a key for the model's api identifier, being careful to leave root level params alone.\n **/\nfunction disambiguateActionParams<Action extends AnyActionFunctionRuntimeMetadata>(\n  action: Action,\n  idValue: string | undefined,\n  variables: Record<string, any> = {}\n): Record<string, any> {\n  if (action.hasAmbiguousIdentifier) {\n    if (Object.keys(variables).some((key) => !action.paramOnlyVariables?.includes(key) && key !== action.modelApiIdentifier)) {\n      throw Error(`Invalid arguments found in variables. Did you mean to use ({ ${action.modelApiIdentifier}: { ... } })?`);\n    }\n  }\n\n  let newVariables: Record<string, any>;\n  const idVariable = Object.entries(action.variables).find(([key, value]) => key === \"id\" && value.type === \"GadgetID\");\n\n  if ((action as any).acceptsModelInput || action.hasCreateOrUpdateEffect) {\n    if (\n      (action.modelApiIdentifier in variables &&\n        typeof variables[action.modelApiIdentifier] === \"object\" &&\n        variables[action.modelApiIdentifier] !== null) ||\n      !action.variables[action.modelApiIdentifier]\n    ) {\n      newVariables = variables;\n    } else {\n      newVariables = {\n        [action.modelApiIdentifier]: {},\n      };\n      for (const [key, value] of Object.entries(variables)) {\n        if (action.paramOnlyVariables?.includes(key)) {\n          newVariables[key] = value;\n        } else {\n          if (idVariable && key === idVariable[0]) {\n            newVariables[\"id\"] = value;\n          } else {\n            newVariables[action.modelApiIdentifier][key] = value;\n          }\n        }\n      }\n    }\n  } else {\n    newVariables = variables;\n  }\n\n  newVariables[\"id\"] ??= idValue as any;\n\n  return newVariables;\n}\n\n/** Split out the arguments to a call to an action */\nfunction actionArgs(\n  operation: AnyActionFunctionRuntimeMetadata,\n  hasId: boolean,\n  hasOthers: boolean,\n  args: (string | Record<string, unknown> | BaseFindOptions)[]\n): [variables: VariablesOptions, options?: BaseFindOptions] {\n  let id: string | undefined = undefined;\n  let params: Record<string, unknown> | undefined = undefined;\n\n  if (hasId) {\n    id = args.shift() as string | undefined;\n  }\n  if (hasOthers) {\n    params = args.shift() as Record<string, unknown> | undefined;\n  }\n  const options = args.shift() as BaseFindOptions;\n\n  let unambiguousParams = params;\n  if (id || params) {\n    unambiguousParams = disambiguateActionParams(operation, id, params);\n  }\n\n  const resultVariables: VariablesOptions = {};\n  for (const [name, variable] of Object.entries(operation.variables)) {\n    resultVariables[name] = {\n      value: name == \"id\" ? id : unambiguousParams?.[name],\n      ...variable,\n    };\n  }\n\n  return [resultVariables, options];\n}\n\n/** Given a result from a finder function that is either a promise for one value or an async iterator over many values, transform each value using a function, returning the same cardinality as the input */\nfunction forEachMaybeLiveResponse<Item, Result>(response: AsyncIterable<Item>, transform: (item: Item) => Result): AsyncIterable<Result>;\nfunction forEachMaybeLiveResponse<Item, Result>(response: Promise<Item>, transform: (item: Item) => Result): Promise<Result>;\nfunction forEachMaybeLiveResponse<Item, Result>(\n  response: AsyncIterable<Item> | Promise<Item>,\n  transform: (item: Item) => Result\n): AsyncIterable<Result> | Promise<Result> {\n  if (Symbol.asyncIterator in response) {\n    return {\n      [Symbol.asyncIterator]: async function* () {\n        for await (const item of response) {\n          yield transform(item);\n        }\n      },\n    };\n  } else {\n    return response.then(transform);\n  }\n}\n"],
  "mappings": "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",
  "names": ["_a"]
}
