{"version":3,"sources":["/app/packages/framework/src/state-chart/StateMapper.ts"],"sourceRoot":"/app","sourcesContent":["import mapValue, { assert, invert, isEmpty, isObject, isString } from \"../utils\";\n\nexport type StateValueMap = {\n  [key: string]: StateValue;\n};\n\ntype ModelBlob = any;\nexport type StateBlob = any;\n\n/**\n * The value representing a state.\n *\n * For example,\n *\n * - `\"created\"`, for simple states;\n * - `{ \"created\": \"unfulfilled\" }`, for compound states; and\n * - `{ \"created\": { \"fulfilled\": \"no\", \"reviewed\": \"no } } }`, for parallel states.\n */\nexport type StateValue = string | StateValueMap;\n\n/**\n * A value storing the historical state values.\n *\n * For example,\n *\n * ```js\n * {\n *   current: \"created\",\n *   children: {\n *     created: {\n *       current: \"fulfilled\",\n *     },\n *     archive: {\n *       current: \"softDeleted\",\n *     },\n *   }\n * }\n * ```\n */\nexport type StateHistoryValue = {\n  /** The name of the state that was previously active */\n  current: string;\n\n  /** Historical values of all nested states */\n  children?: Record<string, StateHistoryValue>;\n};\n\n/** Data about a state, as returned by lookup by state key via `StateMapper` */\nexport type StateData = {\n  /** The state value for a given state, as we'd persist it in the DB */\n  value: StateValue;\n\n  /** The API identifier for the state (can be changed by the user) */\n  apiIdentifier: string;\n\n  /** The `StateBlob` this state was derived from, as given to the app sandbox */\n  blob: StateBlob;\n\n  /** A path to key to this state from the root, useful with lodash's get/set */\n  path: string[];\n};\n\n/** Deeply map the keys/values of a state value */\nfunction mapStateValue(state: StateValue, mapper: (key: string) => string): StateValue {\n  if (isObject(state)) {\n    const result: StateValueMap = {};\n    for (const [key, value] of Object.entries(state)) {\n      result[mapper(key)] = mapStateValue(value, mapper);\n    }\n    return result;\n  }\n\n  return mapper(state);\n}\n\n/** Deeply map the keys/values of a state history value */\nfunction mapStateHistoryValue(state: StateHistoryValue, mapper: (key: string) => string): StateHistoryValue {\n  const result: StateHistoryValue = {\n    current: mapper(state.current),\n  };\n\n  if (state.children) {\n    result.children = {};\n    for (const [name, history] of Object.entries(state.children)) {\n      result.children[mapper(name)] = mapStateHistoryValue(history, mapper);\n    }\n  }\n\n  return result;\n}\n\n/** Determine if a given value is a state value */\nexport function isStateValue(value: any): value is StateValue {\n  if (isString(value)) {\n    return true;\n  }\n\n  if (!isObject(value)) {\n    return false;\n  }\n\n  return Object.entries(value).every(([key, value]) => isString(key) && isStateValue(value));\n}\n\n/** Determine if a given value is a state history value */\nexport function isStateHistoryValue(value: any): value is StateHistoryValue {\n  if (!isObject(value)) {\n    return false;\n  }\n\n  const record = value as Record<string, any>;\n  if (!(\"current\" in record) || !isString(record.current)) {\n    return false;\n  }\n\n  if (\"children\" in record && record.children) {\n    if (!isObject(record.children)) {\n      return false;\n    }\n\n    return Object.values(record.children).every((v) => isStateHistoryValue(v));\n  }\n\n  return true;\n}\n\n/**\n * Map state keys to data on those states.\n *\n * The things in the state chart are deeply nested, so the `StateMapper` takes care of flattening this structure into an efficient lookup\n * table, based on the state keys.\n *\n * `StateMapper` also exposes functions to map back and forth between transit state values (using the API identifiers) and storage state\n * values (using state keys).\n */\nexport class StateMapper {\n  stateKeyToDataMap: { [key: string]: StateData } = {};\n\n  constructor(readonly model: ModelBlob) {\n    this.populateStateMaps(model.stateChart.childStates, []);\n  }\n\n  mapStorageValueToApiIdentifiers(stateValue: StateValue): StateValue {\n    return mapStateValue(stateValue, (key: string) => {\n      if (key in this.stateKeyToDataMap) {\n        return this.stateKeyToDataMap[key].apiIdentifier;\n      }\n      return key;\n    });\n  }\n\n  mapApiIdentifiersToStorageValue(stateValue: StateValue): StateValue {\n    return mapStateValue(stateValue, (apiIdentifier: string) => {\n      if (apiIdentifier in this.apiIdentifierToStateKeyMap) {\n        return this.apiIdentifierToStateKeyMap[apiIdentifier];\n      }\n      return apiIdentifier;\n    });\n  }\n\n  mapStorageHistoryValueToApiIdentifiers(stateHistoryValue: StateHistoryValue): StateHistoryValue {\n    return mapStateHistoryValue(stateHistoryValue, (key: string) => {\n      if (key in this.stateKeyToDataMap) {\n        return this.stateKeyToDataMap[key].apiIdentifier;\n      }\n      return key;\n    });\n  }\n\n  mapApiIdentifiersToStorageHistoryValue(stateHistoryValue: StateHistoryValue): StateHistoryValue {\n    return mapStateHistoryValue(stateHistoryValue, (apiIdentifier: string) => {\n      if (apiIdentifier in this.apiIdentifierToStateKeyMap) {\n        return this.apiIdentifierToStateKeyMap[apiIdentifier];\n      }\n      return apiIdentifier;\n    });\n  }\n\n  public stateKeyToData(stateKey: string): StateData {\n    return assert(this.stateKeyToDataMap[stateKey], `state key \"${stateKey}\" not found in state map`);\n  }\n\n  public get apiIdentifierToStateKeyMap(): Record<string, string> {\n    return invert(mapValue(this.stateKeyToDataMap, ({ apiIdentifier }: any) => apiIdentifier));\n  }\n\n  public populateStateMaps(states: StateBlob[], path: string[]): void {\n    for (const state of states) {\n      path.push(state.apiIdentifier);\n\n      this.stateKeyToDataMap[state.key] = {\n        apiIdentifier: state.apiIdentifier,\n        blob: state,\n        value: stateValueFromPath(path),\n        path: path.slice(),\n      };\n\n      if (state.childStates) {\n        this.populateStateMaps(state.childStates, path);\n      }\n\n      path.pop();\n    }\n  }\n}\n\n/**\n * Compute a state value, from a \"path\" of identifiers.\n *\n * **NOTE**: State values are persisted, so bear that in mind when changing the shape.\n */\nexport function stateValueFromPath(path: string[]): StateValue {\n  if (path.length == 0) {\n    // Note, we're not throwing a special error here because we're in control of the code that calls this method, and should always pass in a non-empty path\n    throw new Error(\"can't compute state value from an empty path\");\n  }\n\n  if (path.length == 1) {\n    return path[0];\n  }\n\n  let index = path.length - 1;\n  let stateValue: StateValue = path[index];\n  while (--index >= 0) {\n    const stateApiIdentifier = path[index];\n    stateValue = { [stateApiIdentifier]: stateValue };\n  }\n  return stateValue;\n}\n\n/**\n * Flatten a state value.\n *\n * For example,\n *\n * ```json\n * { \"created\": { \"unfulfilled\": \"needsReview\" } } }\n * ```\n *\n * will be flattened into `[\"created\", \"unfulfilled\", \"needsReview\"]`\n */\nexport function flattenStateValue(state: StateValue): string[] {\n  if (isString(state)) {\n    return [state];\n  }\n\n  if (isEmpty(state)) {\n    return [];\n  }\n\n  const [key, stateValue] = Object.entries(state)[0];\n  return [key, ...flattenStateValue(stateValue)];\n}\n"],"names":["StateMapper","flattenStateValue","isStateHistoryValue","isStateValue","stateValueFromPath","mapStateValue","state","mapper","isObject","result","key","value","Object","entries","mapStateHistoryValue","current","children","name","history","isString","every","record","values","v","stateKeyToDataMap","constructor","model","populateStateMaps","stateChart","childStates","mapStorageValueToApiIdentifiers","stateValue","apiIdentifier","mapApiIdentifiersToStorageValue","apiIdentifierToStateKeyMap","mapStorageHistoryValueToApiIdentifiers","stateHistoryValue","mapApiIdentifiersToStorageHistoryValue","stateKeyToData","stateKey","assert","invert","mapValue","states","path","push","blob","slice","pop","length","Error","index","stateApiIdentifier","isEmpty"],"mappings":"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"}