{"version":3,"sources":["/app/packages/framework/src/vite/helpers.ts"],"sourceRoot":"/app","sourcesContent":["import fs from \"fs/promises\";\nimport path from \"path\";\nimport { remixViteOptions } from \"../remix\";\nimport type { GadgetPluginOptions } from \"./types\";\nimport { getInternalFrontendConfig } from \"./utils\";\n\nexport enum FrontendType {\n  Remix = \"remix\",\n  Vite = \"vite\",\n}\n\nexport const frontendTypeIndicatorFilePath = \".gadget/FRONTEND_TYPE\";\n\nconst maybeGetPluginByName = (name: string, plugin: any) => {\n  if (plugin && \"name\" in plugin && plugin.name === name) {\n    return plugin;\n  }\n};\n\nexport const getFrontendTypeByPluginsUsed = (config: Record<string, any>): FrontendType => {\n  let type = FrontendType.Vite;\n\n  /**\n   * Check if the vite config has a remix plugin.\n   *\n   * We need to find several remix-related plugins because the `remix()` plugin has a list of plugins registered, and Vite will recursively resolve the plugins.\n   * So, when Vite resolves the config, the `config.plugins` array value changes.\n   *\n   * For example, the vite config has two plugins: `[gadget(), remix()]`. When Vite runs dev/build command, this `getFrontendTypeByPluginsUsed()` function is actually called more than once.\n   *\n   * In the first call, the `config.plugins` array value is `[{name: \"gadget-vite-plugin\", ... }, {name: \"remix\", ... }]`. The \"remix\" plugin name is the `remix()` plugin.\n   * However, in a second call, the `config.plugins` array value is `[{name: \"gadget-vite-plugin\", ... }, {name: \"remix-virtual-modules\", ... }, {name: \"remix-hmr-runtime\", ... }]`. They are all from the `remix()` plugin, and the \"remix\" plugin name is no longer in the array.\n   */\n  const hasRemixPlugin = config.plugins?.some((pluginOptions: any) => {\n    if (Array.isArray(pluginOptions)) {\n      return pluginOptions.some((plugin) => maybeGetPluginByName(\"remix\", plugin));\n    } else {\n      return !!maybeGetPluginByName(\"remix-virtual-modules\", pluginOptions);\n    }\n  });\n\n  if (hasRemixPlugin) {\n    type = FrontendType.Remix;\n  }\n\n  return type;\n};\n\nexport const doesViteConfigHasGadgetPlugin = (config: Record<string, any>): boolean => {\n  return (\n    config.plugins?.some((plugin: any) => {\n      return !!maybeGetPluginByName(\"gadget-vite-plugin\", plugin);\n    }) ?? false\n  );\n};\n\nexport const getViteConfig = async (\n  config: any,\n  { command, mode, isSsrBuild }: { command: \"serve\" | \"build\"; mode: \"development\" | \"production\"; isSsrBuild?: boolean },\n  options: {\n    plugin?: GadgetPluginOptions;\n    params: {\n      assetsBucketDomain: string;\n      applicationId: string;\n      productionEnvironmentId: string;\n      developmentEnvironmentVariables: Record<string, string>;\n      productionEnvironmentVariables: Record<string, string>;\n    };\n  }\n): Promise<void> => {\n  const { assetsBucketDomain, applicationId, productionEnvironmentId } = options.params;\n\n  const type = getFrontendTypeByPluginsUsed(config);\n  const frontendConfig = getInternalFrontendConfig(type);\n\n  config.envPrefix = VITE_PUBLIC_ENV_PREFIXES;\n\n  config.build = {\n    ...config.build,\n    manifest: true,\n  };\n\n  // in ssr mode use the real process.env\n  if (!isSsrBuild) {\n    // set up the defines for our process.env.WHATEVER polyfill (which vite doesn't do on its own)\n    const vars = mode === \"development\" ? options.params.developmentEnvironmentVariables : options.params.productionEnvironmentVariables;\n    // merge the decided-upon vars into process.env so vite will use them for `import.meta.env`\n    for (const [key, value] of Object.entries(vars)) {\n      process.env[key] = value;\n    }\n\n    config.define = { ...buildDefinesMap(vars, mode), ...config.define };\n  }\n\n  switch (type) {\n    case FrontendType.Vite:\n      config.build = {\n        ...config.build,\n        outDir: \"./.gadget/vite-dist\",\n        emptyOutDir: true,\n      };\n      break;\n\n    default:\n      break;\n  }\n\n  if (command === \"build\") {\n    await fs.mkdir(\".gadget\", { recursive: true });\n    await fs.writeFile(frontendTypeIndicatorFilePath, type);\n\n    // Serve the assets from the Gadget CDN in production\n    config.base = frontendConfig.productionBaseUrl(assetsBucketDomain, applicationId, productionEnvironmentId);\n\n    // Remix doesn't include the trailing slash in the base URL when building, so we need to add it manually\n    if (type === FrontendType.Remix) {\n      const parentDirectory = path.join(remixViteOptions.buildDirectory, \"..\");\n      await fs.mkdir(parentDirectory, { recursive: true });\n      await fs.writeFile(path.join(parentDirectory, \"package.json\"), `{\"type\": \"module\"}`);\n    }\n  }\n};\n\ninterface HtmlTagDescriptor {\n  tag: string;\n  attrs: Record<string, string | boolean>;\n  children?: string;\n}\n\nexport const getHtmlTags = (\n  options: {\n    hasAppBridgeV4: boolean;\n    hasBigCommerceConnection: boolean;\n    assetsDomain: string;\n  },\n  devMode: boolean\n): HtmlTagDescriptor[] => {\n  const tags: HtmlTagDescriptor[] = [];\n\n  if (options.hasAppBridgeV4) {\n    tags.push({\n      tag: \"script\",\n      attrs: {\n        src: `https://cdn.shopify.com/shopifycloud/app-bridge.js`,\n        \"data-api-key\": \"%SHOPIFY_API_KEY%\",\n      },\n    });\n  }\n\n  if (options.hasBigCommerceConnection) {\n    tags.push({\n      tag: \"script\",\n      attrs: {\n        src: `https://cdn.bigcommerce.com/jssdk/bc-sdk.js`,\n      },\n    });\n  }\n\n  if (devMode) {\n    tags.push({\n      tag: \"script\",\n      attrs: { type: \"module\" },\n      children: `\n        if (import.meta.hot) {\n          import.meta.hot.on(\"gadget:viteError\", (data) => {\n            const event = new CustomEvent(\"gadget:viteError\", {\n              detail: data,\n            });\n            window.dispatchEvent(event);\n          });\n        }\n      `,\n    });\n\n    tags.push({\n      tag: \"script\",\n      attrs: {\n        async: true,\n        crossorigin: true,\n        src: `https://${options.assetsDomain}/assets/devHarness.min.js`,\n      },\n    });\n  }\n\n  return tags;\n};\n\n/** Given a list of environment variables, set up the defines for Vite to replace process.env.FOO with these valuies */\nexport const buildDefinesMap = (env: Record<string, string | undefined>, mode: \"development\" | \"production\"): Record<string, string> => {\n  const defines: Record<string, string> = {\n    // this one pesky env var changes based on the requester at runtime, so we can't define it statically at build time. we rely on it being injected into the global scope by the serving layer. it is important that this more specific define is before the catch-all process.env define below\n    \"process.env.GADGET_PUBLIC_SHOPIFY_APP_URL\": \"globalThis.gadgetPublicShopifyAppUrl\",\n  };\n\n  // add specific define replacements for env vars that might be used at build time so that we don't interpolate the large env object for every reference every time and bloat the bundle size\n  for (const [key, value] of Object.entries(env)) {\n    if (value) {\n      defines[`process.env.${key}`] = JSON.stringify(value);\n    }\n  }\n\n  // to support square bracket syntax or Object.keys or what have you in production mode, we also define the whole object this way\n  // we do not need to do this in development mode because vite will define process.env as a global variable that we can access as any other object\n  if (mode === \"production\") {\n    defines[\"process.env\"] = JSON.stringify(env);\n  }\n\n  return defines;\n};\n\nexport const VITE_PUBLIC_ENV_PREFIXES: string[] = [\"GADGET_PUBLIC_\", \"VITE_\", \"GADGET_APP\", \"GADGET_ENV\"];\n"],"names":["VITE_PUBLIC_ENV_PREFIXES","buildDefinesMap","doesViteConfigHasGadgetPlugin","frontendTypeIndicatorFilePath","getFrontendTypeByPluginsUsed","getHtmlTags","getViteConfig","FrontendType","maybeGetPluginByName","name","plugin","config","type","hasRemixPlugin","plugins","some","pluginOptions","Array","isArray","command","mode","isSsrBuild","options","assetsBucketDomain","applicationId","productionEnvironmentId","params","frontendConfig","getInternalFrontendConfig","envPrefix","build","manifest","vars","developmentEnvironmentVariables","productionEnvironmentVariables","key","value","Object","entries","process","env","define","outDir","emptyOutDir","fs","mkdir","recursive","writeFile","base","productionBaseUrl","parentDirectory","path","join","remixViteOptions","buildDirectory","devMode","tags","hasAppBridgeV4","push","tag","attrs","src","hasBigCommerceConnection","children","async","crossorigin","assetsDomain","defines","JSON","stringify"],"mappings":";;;;;;;;;;;;;;IAkNaA,wBAAwB;eAAxBA;;IAtBAC,eAAe;eAAfA;;IA5IAC,6BAA6B;eAA7BA;;IArCAC,6BAA6B;eAA7BA;;IAQAC,4BAA4B;eAA5BA;;IA8GAC,WAAW;eAAXA;;IAzEAC,aAAa;eAAbA;;;;;;;;;;;oEAxDE;;;;;;;oEACE;;;;;;uBACgB;uBAES;;UAE9BC;;;GAAAA,iBAAAA;AAKL,MAAMJ,gCAAgC;AAE7C,MAAMK,uBAAuB,CAACC,MAAcC;IAC1C,IAAIA,UAAU,UAAUA,UAAUA,OAAOD,IAAI,KAAKA,MAAM;QACtD,OAAOC;IACT;AACF;AAEO,MAAMN,+BAA+B,CAACO;IAC3C,IAAIC;IAEJ;;;;;;;;;;GAUC,GACD,MAAMC,iBAAiBF,OAAOG,OAAO,EAAEC,KAAK,CAACC;QAC3C,IAAIC,MAAMC,OAAO,CAACF,gBAAgB;YAChC,OAAOA,cAAcD,IAAI,CAAC,CAACL,SAAWF,qBAAqB,SAASE;QACtE,OAAO;YACL,OAAO,CAAC,CAACF,qBAAqB,yBAAyBQ;QACzD;IACF;IAEA,IAAIH,gBAAgB;QAClBD;IACF;IAEA,OAAOA;AACT;AAEO,MAAMV,gCAAgC,CAACS;IAC5C,OACEA,OAAOG,OAAO,EAAEC,KAAK,CAACL;QACpB,OAAO,CAAC,CAACF,qBAAqB,sBAAsBE;IACtD,MAAM;AAEV;AAEO,MAAMJ,gBAAgB,OAC3BK,QACA,EAAEQ,OAAO,EAAEC,IAAI,EAAEC,UAAU,EAA4F,EACvHC;IAWA,MAAM,EAAEC,kBAAkB,EAAEC,aAAa,EAAEC,uBAAuB,EAAE,GAAGH,QAAQI,MAAM;IAErF,MAAMd,OAAOR,6BAA6BO;IAC1C,MAAMgB,iBAAiBC,IAAAA,gCAAyB,EAAChB;IAEjDD,OAAOkB,SAAS,GAAG7B;IAEnBW,OAAOmB,KAAK,GAAG;QACb,GAAGnB,OAAOmB,KAAK;QACfC,UAAU;IACZ;IAEA,uCAAuC;IACvC,IAAI,CAACV,YAAY;QACf,8FAA8F;QAC9F,MAAMW,OAAOZ,SAAS,gBAAgBE,QAAQI,MAAM,CAACO,+BAA+B,GAAGX,QAAQI,MAAM,CAACQ,8BAA8B;QACpI,2FAA2F;QAC3F,KAAK,MAAM,CAACC,KAAKC,MAAM,IAAIC,OAAOC,OAAO,CAACN,MAAO;YAC/CO,QAAQC,GAAG,CAACL,IAAI,GAAGC;QACrB;QAEAzB,OAAO8B,MAAM,GAAG;YAAE,GAAGxC,gBAAgB+B,MAAMZ,KAAK;YAAE,GAAGT,OAAO8B,MAAM;QAAC;IACrE;IAEA,OAAQ7B;QACN;YACED,OAAOmB,KAAK,GAAG;gBACb,GAAGnB,OAAOmB,KAAK;gBACfY,QAAQ;gBACRC,aAAa;YACf;YACA;QAEF;YACE;IACJ;IAEA,IAAIxB,YAAY,SAAS;QACvB,MAAMyB,mBAAE,CAACC,KAAK,CAAC,WAAW;YAAEC,WAAW;QAAK;QAC5C,MAAMF,mBAAE,CAACG,SAAS,CAAC5C,+BAA+BS;QAElD,qDAAqD;QACrDD,OAAOqC,IAAI,GAAGrB,eAAesB,iBAAiB,CAAC1B,oBAAoBC,eAAeC;QAElF,wGAAwG;QACxG,IAAIb,kBAA6B;YAC/B,MAAMsC,kBAAkBC,eAAI,CAACC,IAAI,CAACC,uBAAgB,CAACC,cAAc,EAAE;YACnE,MAAMV,mBAAE,CAACC,KAAK,CAACK,iBAAiB;gBAAEJ,WAAW;YAAK;YAClD,MAAMF,mBAAE,CAACG,SAAS,CAACI,eAAI,CAACC,IAAI,CAACF,iBAAiB,iBAAiB,CAAC,kBAAkB,CAAC;QACrF;IACF;AACF;AAQO,MAAM7C,cAAc,CACzBiB,SAKAiC;IAEA,MAAMC,OAA4B,EAAE;IAEpC,IAAIlC,QAAQmC,cAAc,EAAE;QAC1BD,KAAKE,IAAI,CAAC;YACRC,KAAK;YACLC,OAAO;gBACLC,KAAK,CAAC,kDAAkD,CAAC;gBACzD,gBAAgB;YAClB;QACF;IACF;IAEA,IAAIvC,QAAQwC,wBAAwB,EAAE;QACpCN,KAAKE,IAAI,CAAC;YACRC,KAAK;YACLC,OAAO;gBACLC,KAAK,CAAC,2CAA2C,CAAC;YACpD;QACF;IACF;IAEA,IAAIN,SAAS;QACXC,KAAKE,IAAI,CAAC;YACRC,KAAK;YACLC,OAAO;gBAAEhD,MAAM;YAAS;YACxBmD,UAAU,CAAC;;;;;;;;;MASX,CAAC;QACH;QAEAP,KAAKE,IAAI,CAAC;YACRC,KAAK;YACLC,OAAO;gBACLI,OAAO;gBACPC,aAAa;gBACbJ,KAAK,CAAC,QAAQ,EAAEvC,QAAQ4C,YAAY,CAAC,yBAAyB,CAAC;YACjE;QACF;IACF;IAEA,OAAOV;AACT;AAGO,MAAMvD,kBAAkB,CAACuC,KAAyCpB;IACvE,MAAM+C,UAAkC;QACtC,6RAA6R;QAC7R,6CAA6C;IAC/C;IAEA,4LAA4L;IAC5L,KAAK,MAAM,CAAChC,KAAKC,MAAM,IAAIC,OAAOC,OAAO,CAACE,KAAM;QAC9C,IAAIJ,OAAO;YACT+B,OAAO,CAAC,CAAC,YAAY,EAAEhC,IAAI,CAAC,CAAC,GAAGiC,KAAKC,SAAS,CAACjC;QACjD;IACF;IAEA,gIAAgI;IAChI,iJAAiJ;IACjJ,IAAIhB,SAAS,cAAc;QACzB+C,OAAO,CAAC,cAAc,GAAGC,KAAKC,SAAS,CAAC7B;IAC1C;IAEA,OAAO2B;AACT;AAEO,MAAMnE,2BAAqC;IAAC;IAAkB;IAAS;IAAc;CAAa"}