{"version":3,"sources":["/app/packages/framework/src/bigcommerce/effects.ts"],"sourceRoot":"/app","sourcesContent":["import type { GadgetRecord } from \"@gadgetinc/api-client-core\";\nimport { FieldType, getActionContextFromLocalStorage, LINK_PARAM } from \"../effects\";\nimport { MisconfiguredActionError, PermissionDeniedError } from \"../errors\";\nimport { Globals } from \"../globals\";\nimport type { BigCommerceTenancy } from \"../tenancy\";\nimport { AppTenancyKey } from \"../tenancy\";\nimport type { AnyParams, FieldMetadata, ModelDescriptor } from \"../types\";\n\n/**\n * Applicable for multi-tenant Store apps(public apps)\n * Enforces that the given record is only accessible by the current store or customer\n * *\n * @param params - incoming data validated against the current `storeHash`\n * @param record - record used to validate or set the `storeHash` on\n */\nexport async function preventCrossStoreDataAccess(\n  params: AnyParams,\n  record: GadgetRecord<any>,\n  options?: { storeBelongsToField?: string }\n): Promise<void> {\n  const context = getActionContextFromLocalStorage();\n\n  if (context.type != \"effect\") {\n    throw new Error(\"Can't prevent cross store data access outside of an action effect\");\n  }\n  if (!params) {\n    throw new Error(\"The `params` parameter is required in preventCrossStoreDataAccess(params, record)\");\n  }\n  if (!record) {\n    throw new Error(\"The `record` parameter is required in preventCrossStoreDataAccess(params, record)\");\n  }\n\n  const model = context.model;\n  const appTenancy = context[AppTenancyKey];\n\n  // if there's no tenancy let's continue\n  if (appTenancy?.bigcommerce?.storeId === undefined) {\n    return;\n  }\n\n  // if this effect is not run in the context of a model then it does not apply\n  if (!model) {\n    return;\n  }\n\n  const input = params[model.apiIdentifier];\n  const storeBelongsToField = options?.storeBelongsToField;\n  validateBelongsToLink({\n    input,\n    record,\n    params,\n    model,\n    tenancy: appTenancy.bigcommerce,\n    relatedModelKey: bigcommerceStoreKey,\n    tenantBelongsToField: storeBelongsToField,\n    tenantType: TenantType.Store,\n  });\n}\n\nconst bigcommerceModelKey = (modelName: string): string => {\n  const modelKey = modelName.replaceAll(\" \", \"\");\n  return `DataModel-BigCommerce-${modelKey}`;\n};\n\nconst bigcommerceStoreKey: string = bigcommerceModelKey(\"Store\");\n\nconst validateBelongsToLink = (options: {\n  input: any;\n  record: any;\n  params: AnyParams;\n  tenancy: BigCommerceTenancy;\n  model: ModelDescriptor;\n  relatedModelKey: string;\n  tenantBelongsToField?: string | undefined;\n  tenantType: TenantType;\n}) => {\n  const { input, record, params, tenancy, model, relatedModelKey, tenantType, tenantBelongsToField } = options;\n  if (relatedModelKey != bigcommerceStoreKey) {\n    throw new Error(\"Validation for tenancy can only be Big Commerce Store\");\n  }\n\n  // If this effect is being added to the related tenant model (BigCommerce Store), simply compare the record's ID\n  if (model.key == relatedModelKey) {\n    if (record && String(record.id) !== tenancy.storeId) {\n      throw new PermissionDeniedError();\n    }\n    return;\n  }\n\n  const fieldsIsBelongsToRelatedModel = Object.values(model.fields).filter(\n    (f) => f.fieldType === (FieldType.BelongsTo as string) && f.configuration.relatedModelKey === relatedModelKey\n  );\n\n  if (fieldsIsBelongsToRelatedModel.length === 0) {\n    throw new MisconfiguredActionError(`This model is missing a related ${tenantType} field.`);\n  }\n\n  if (fieldsIsBelongsToRelatedModel.length > 1 && !tenantBelongsToField) {\n    throw new MisconfiguredActionError(\n      `This function is missing a related ${tenantType} field option. \\`${tenantType}BelongsToField\\` is a required option parameter if the model has more than one related ${tenantType} field.`\n    );\n  }\n  let relatedTenantField = fieldsIsBelongsToRelatedModel[0];\n\n  if (tenantBelongsToField) {\n    const selectedField = Object.values(model.fields).find((f) => f.apiIdentifier === tenantBelongsToField);\n    if (!selectedField) {\n      throw new MisconfiguredActionError(`The selected ${tenantType} relation field does not exist.`);\n    }\n\n    if (selectedField.fieldType !== (FieldType.BelongsTo as string) || selectedField.configuration.relatedModelKey !== relatedModelKey) {\n      throw new MisconfiguredActionError(\n        `The selected ${tenantType} relation field should be a \\`Belongs To\\` relationship to the \\`BigCommerce ${Globals.platformModules\n          .lodash()\n          .capitalize(tenantType)}\\` model.`\n      );\n    } else {\n      relatedTenantField = selectedField;\n    }\n  }\n\n  setBelongsToLink(input, record, params, model, relatedTenantField, tenancy.storeId);\n};\n\nconst setBelongsToLink = (\n  input: any,\n  record: any,\n  params: AnyParams,\n  model: ModelDescriptor,\n  relatedField: FieldMetadata,\n  tenantId: string\n) => {\n  // if we're trying to set the params to a store other than the tenant we should reject\n  if (Globals.platformModules.lodash().isObjectLike(input)) {\n    const objectInput = input as Record<string, any>;\n    if (objectInput[relatedField.apiIdentifier]) {\n      if (String(objectInput[relatedField.apiIdentifier][LINK_PARAM]) !== tenantId) {\n        throw new PermissionDeniedError();\n      }\n    } else {\n      objectInput[relatedField.apiIdentifier] = {\n        [LINK_PARAM]: tenantId,\n      };\n    }\n  } else {\n    params[model.apiIdentifier] = {\n      [relatedField.apiIdentifier]: {\n        [LINK_PARAM]: tenantId,\n      },\n    };\n  }\n\n  if (record) {\n    const value = record.getField(relatedField.apiIdentifier);\n    // if the record doesn't have a shop set then anyone can update it\n    if (value) {\n      const recordShopId = typeof value === \"object\" ? value[LINK_PARAM] : value;\n      if (String(recordShopId) !== tenantId) {\n        throw new PermissionDeniedError();\n      }\n    } else {\n      // we have to re-apply the params to the record to ensure that this still works correctly if it occurs after \"applyParams\"\n      record.setField(relatedField.apiIdentifier, {\n        [LINK_PARAM]: tenantId,\n      });\n    }\n  }\n};\n\nconst enum TenantType {\n  Store = \"store\",\n}\n"],"names":["preventCrossStoreDataAccess","params","record","options","context","getActionContextFromLocalStorage","type","Error","model","appTenancy","AppTenancyKey","bigcommerce","storeId","undefined","input","apiIdentifier","storeBelongsToField","validateBelongsToLink","tenancy","relatedModelKey","bigcommerceStoreKey","tenantBelongsToField","tenantType","bigcommerceModelKey","modelName","modelKey","replaceAll","key","String","id","PermissionDeniedError","fieldsIsBelongsToRelatedModel","Object","values","fields","filter","f","fieldType","FieldType","BelongsTo","configuration","length","MisconfiguredActionError","relatedTenantField","selectedField","find","Globals","platformModules","lodash","capitalize","setBelongsToLink","relatedField","tenantId","isObjectLike","objectInput","LINK_PARAM","value","getField","recordShopId","setField"],"mappings":"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"}