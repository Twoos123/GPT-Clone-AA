{
  "version": 3,
  "sources": ["../src/auth.ts"],
  "sourcesContent": ["import type { FastifyReply, FastifyRequest } from \"fastify\";\nimport crypto from \"node:crypto\";\nimport type { Session } from \"./Session\";\n\ndeclare module \"fastify\" {\n  interface FastifyRequest {\n    gadgetAuth?: {\n      redirectToSignIn: boolean;\n      signInPath: string;\n    };\n  }\n}\n\nexport const generateCode = (numBytes?: number): string => {\n  return crypto.randomBytes(numBytes ?? 64).toString(\"hex\");\n};\n\nexport const hashCode = (code: string): string => {\n  return crypto.createHash(\"sha256\").update(code).digest(\"hex\");\n};\n\nconst getSessionFromRequest = <Request extends FastifyRequest>(request: Request): Session => {\n  if (\"applicationSession\" in request) {\n    return request.applicationSession as any as Session;\n  }\n\n  throw new Error(\"The request is not a Gadget server request\");\n};\n\n/**\n * Safely compares a password reset code and hash\n * @param {string} [code] - The password reset code\n * @param {string} [hash] - The hashed password reset code\n * @returns {boolean} - Whether the code is valid or not\n */\n\n/**\n * Utility function to wrap route handlers with protection from unauthenticated requests.\n *\n * @param handler The route handler to protect\n * @param {ProtectedRouteOptions} options Options for the protected route\n * @returns handler function that is wrapped with route protection\n *\n * @example\n * ```ts\n * // routes/GET-protected-route.js\n * const { preValidation } = require(\"@gadgetinc/auth\");\n *\n * module.exports = async ({ request, reply }) => {\n *  await reply.send(\"this is a protected route\");\n * }\n *\n * module.options = {\n *  preValidation,\n * }\n * ```\n */\nexport const preValidation = async <RouteContext extends FastifyRequest>(request: RouteContext, reply: FastifyReply): Promise<void> => {\n  let authenticated = false;\n  const applicationSession = getSessionFromRequest(request);\n  authenticated = !!applicationSession.get(\"user\");\n\n  if (!authenticated) {\n    if (request.gadgetAuth?.redirectToSignIn) {\n      await reply.redirect(request.gadgetAuth.signInPath);\n    } else {\n      await reply.status(403).send();\n    }\n  }\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,yBAAmB;AAYZ,MAAM,eAAe,CAAC,aAA8B;AACzD,SAAO,mBAAAA,QAAO,YAAY,YAAY,EAAE,EAAE,SAAS,KAAK;AAC1D;AAEO,MAAM,WAAW,CAAC,SAAyB;AAChD,SAAO,mBAAAA,QAAO,WAAW,QAAQ,EAAE,OAAO,IAAI,EAAE,OAAO,KAAK;AAC9D;AAEA,MAAM,wBAAwB,CAAiC,YAA8B;AAC3F,MAAI,wBAAwB,SAAS;AACnC,WAAO,QAAQ;AAAA,EACjB;AAEA,QAAM,IAAI,MAAM,4CAA4C;AAC9D;AA8BO,MAAM,gBAAgB,OAA4C,SAAuB,UAAuC;AACrI,MAAI,gBAAgB;AACpB,QAAM,qBAAqB,sBAAsB,OAAO;AACxD,kBAAgB,CAAC,CAAC,mBAAmB,IAAI,MAAM;AAE/C,MAAI,CAAC,eAAe;AAClB,QAAI,QAAQ,YAAY,kBAAkB;AACxC,YAAM,MAAM,SAAS,QAAQ,WAAW,UAAU;AAAA,IACpD,OAAO;AACL,YAAM,MAAM,OAAO,GAAG,EAAE,KAAK;AAAA,IAC/B;AAAA,EACF;AACF;",
  "names": ["crypto"]
}
