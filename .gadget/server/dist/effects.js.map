{
  "version": 3,
  "sources": ["../src/effects.ts"],
  "sourcesContent": ["import type { AnyClient, InternalModelManager, RecordData } from \"@gadgetinc/api-client-core\";\nimport { ChangeTracking, GadgetRecord } from \"@gadgetinc/api-client-core\";\nimport { InternalError, InvalidStateTransitionError, NoSessionForAuthenticationError, UserNotSetOnSessionError } from \"./errors\";\nimport { Globals, actionContextLocalStorage } from \"./globals\";\nimport { frameworkVersion, modelListIndex, modelsMap } from \"./metadata\";\nimport type {\n  AnyActionContext,\n  AnyAmbientContext,\n  AnyEffectContext,\n  AnyGlobalActionContext,\n  AnyParams,\n  ModelMetadata,\n  NotYetTyped,\n} from \"./types\";\nimport { assert } from \"./utils\";\n\nexport function getBelongsToRelationParams(model: ModelMetadata, params: Record<string, any>): Record<string, any> {\n  const belongsToParams: Record<string, any> = {};\n\n  for (const field of Object.values(model.fields) as any[]) {\n    if (field.fieldType != \"BelongsTo\") continue;\n    const modelParams = typeof params[model.apiIdentifier] === \"object\" ? params[model.apiIdentifier] : undefined;\n    const belongsToParam =\n      modelParams && typeof modelParams[field.apiIdentifier] === \"object\" ? modelParams[field.apiIdentifier] : undefined;\n    const belongsToId = belongsToParam?.[LINK_PARAM] !== undefined ? belongsToParam[LINK_PARAM] : belongsToParam?.id;\n    if (belongsToId !== undefined) {\n      belongsToParams[`${field.apiIdentifier}Id`] = belongsToId;\n    }\n  }\n\n  return belongsToParams;\n}\n\nexport function createGadgetRecord<Shape>(apiIdentifier: string, data: Shape): GadgetRecord<Shape & { __typename: string }> {\n  const model = getModelByApiIdentifier(apiIdentifier);\n  return new GadgetRecord({\n    ...data,\n    __typename: model.graphqlTypeName,\n  });\n}\n\n/**\n * Applies incoming API params (your model\u2019s fields) to a record\n *\n * @param params - data passed from API calls, webhook events, or direct user inputs.\n * @param record - object used to pass params to\n */\nexport function applyParams(params: AnyParams, record: GadgetRecord<any>): void {\n  const model = getModelByTypename(record.__typename);\n  Object.assign(record, params[model.apiIdentifier], getBelongsToRelationParams(model, params));\n}\n\n/**\n * Get the internal model manager for the model from its maybe-namespaced spot\n */\nexport const internalModelManagerForModel = (api: AnyClient, apiIdentifier: string, namespace: string[]): InternalModelManager => {\n  const modelPath = [...namespace, apiIdentifier];\n  const manager: InternalModelManager | undefined = Globals.platformModules.lodash().get(api, [\"internal\", ...modelPath]);\n  if (!manager) {\n    throw new InternalError(\n      `Gadget needs but can't find an internal model manager for ${modelPath.join(\n        \".\"\n      )} on the API client -- has it finished regenerating or was it recently removed?`\n    );\n  }\n\n  return manager;\n};\n\n/**\n * Get the internal model manager for the model from its maybe-namespaced spot\n */\nexport const internalModelManagerForTypename = (api: AnyClient, typename: string): InternalModelManager => {\n  const model = getModelByTypename(typename);\n\n  return internalModelManagerForModel(api, model.apiIdentifier, model.namespace);\n};\n\n/**\n * Saves record to the database:\n * 1. Checks field validations of a given record, then saves the record to the database.\n * 2. Uses your apps Internal API to persist data. This API quickly interacts with data without running any business logic.\n *\n * @param record - object saved to the database\n */\nexport async function save(record: GadgetRecord<any>): Promise<void> {\n  const context = maybeGetActionContextFromLocalStorage();\n  const api = assert(context ? context.api : getCurrentContext().api, \"api client is missing from the current context\");\n  const model = getModelByTypename(record.__typename);\n\n  await (await Globals.modelValidator(model.key)).validate({ api, logger: Globals.logger }, record);\n\n  const internalModelManager = internalModelManagerForTypename(api, record.__typename);\n\n  let result: GadgetRecord<any>;\n\n  if (\"createdAt\" in record && record.createdAt) {\n    result = await internalModelManager.update(record.id, {\n      [model.apiIdentifier]: changedAttributes(model, record),\n    });\n  } else {\n    result = await internalModelManager.create({\n      [model.apiIdentifier]: writableAttributes(model, record),\n    });\n  }\n\n  Object.assign(record, { ...result });\n  record.flushChanges(ChangeTracking.SinceLastPersisted);\n}\n\n/**\n * Deletes record from the database.\n *\n * @param record - object deleted from the database\n */\nexport async function deleteRecord(record: GadgetRecord<any>): Promise<void> {\n  const context = maybeGetActionContextFromLocalStorage();\n\n  const api = assert(context ? context.api : getCurrentContext().api, \"api client is missing from the current context\");\n  const scope = context ? context.scope : {};\n\n  const id = assert(record.id, `record.id not set on record in scope, has the record been persisted?`);\n\n  const internalModelManager = internalModelManagerForTypename(api, record.__typename);\n  await internalModelManager.delete(id);\n\n  scope.recordDeleted = true;\n}\n\nexport function transitionState(\n  record: GadgetRecord<any>,\n  transition: {\n    from?: string | Record<string, string>;\n    to: string | Record<string, string>;\n  }\n): void {\n  const model = getModelByTypename(record.__typename);\n  const isShopifyModel =\n    model.apiIdentifier === \"shopifyShop\" || model.apiIdentifier === \"shopifySync\" || model.apiIdentifier === \"shopifyBulkOperation\";\n\n  if (isShopifyModel && doesVersionSupportSourceControl()) {\n    // In apps framework version 1.0.0+, we handle the state transition internally to Shopify models based on the above API identifiers.\n    // This function becomes a no-op for those models.\n    return;\n  }\n\n  const stringRecordState = typeof record.state === \"string\" ? record.state : JSON.stringify(record.state);\n  const stringTransitionFrom = typeof transition.from === \"string\" ? transition.from : JSON.stringify(transition.from);\n\n  if (transition.from && stringRecordState !== stringTransitionFrom) {\n    throw new InvalidStateTransitionError(undefined, {\n      state: record.state,\n      expectedFrom: transition.from,\n    });\n  }\n\n  record.state = transition.to;\n}\n\nexport function legacySetUser(): void {\n  const context = getActionContextFromLocalStorage();\n\n  if (!context.scope.authenticatedUser) {\n    throw new UserNotSetOnSessionError(\n      \"The authenticated user could not be saved to the session when logging in. Make sure the user has a role assigned to them.\"\n    );\n  }\n  if (!context.session) {\n    throw new NoSessionForAuthenticationError(\n      \"Unable to authenticate because the request was made with no session in context to transition.\"\n    );\n  }\n  context.session.set(\"user\", { [LINK_PARAM]: context.scope.authenticatedUser.id });\n}\n\nexport function legacyUnsetUser(): void {\n  const context = getActionContextFromLocalStorage();\n\n  if (!context.session) {\n    throw new NoSessionForAuthenticationError(\"Unable to unset users on session because the request was made with no session.\");\n  }\n  context.session.delete(\"user\");\n}\n\nexport async function legacySuccessfulAuthentication(params: AnyParams): Promise<void> {\n  const context = getActionContextFromLocalStorage();\n  const { api, scope } = context;\n  const manager = api.internal.user as InternalModelManager;\n\n  const user = (await manager.findMany({ filter: { email: { equals: params.email } } }))[0];\n  let result = false;\n  if (user && params.password && user.password?.hash) {\n    if (await Globals.platformModules.bcrypt().compare(params.password, user.password.hash)) {\n      scope.authenticatedUser = user;\n      result = true;\n    }\n  }\n  Globals.logger.info({ email: params.email, userId: user?.id, result }, \"login attempt\");\n\n  if (!result) {\n    throw new Error(\"Invalid email or password\");\n  }\n}\n\n/**\n * @private helper functions and variables\n */\n\nexport function doesVersionSupportSourceControl(): boolean {\n  return Globals.platformModules.compareVersions().satisfies(frameworkVersion, \">=1.0.0\");\n}\n\n/**\n * @private Get action context without `params` and `record` from async local storage.\n */\nexport function getActionContextFromLocalStorage(): AnyActionContext | AnyGlobalActionContext | AnyEffectContext {\n  return assert(actionContextLocalStorage.getStore(), \"this effect function should only be called from within an action\");\n}\n\n/**\n * @private Similar to `getActionContextFromLocalStorage` but returns `undefined` if there is no action context. (i.e. possibly called from a route)\n */\nexport function maybeGetActionContextFromLocalStorage(): AnyActionContext | AnyGlobalActionContext | AnyEffectContext | undefined {\n  return actionContextLocalStorage.getStore();\n}\n\nexport function getCurrentContext(): AnyAmbientContext {\n  return assert(Globals.requestContext.get(\"requestContext\"), \"no gadget context found on request\");\n}\n\nexport const LINK_PARAM = \"_link\";\n\nexport function writableAttributes(model: ModelMetadata, record: GadgetRecord<RecordData>): Record<string, any> {\n  const fieldsByApiIdentifier = Globals.platformModules.lodash().keyBy(Object.values(model.fields) as NotYetTyped[], \"apiIdentifier\");\n  return Globals.platformModules.lodash().pickBy(record, (v: any, k: any) => {\n    const field = fieldsByApiIdentifier[k];\n    if (!field) return false;\n\n    const isRelationshipField =\n      field.fieldType === FieldType.HasMany || field.fieldType === FieldType.HasOne || field.fieldType === FieldType.HasManyThrough;\n\n    if (isRelationshipField && v === null) {\n      return false;\n    }\n\n    return field.internalWritable;\n  });\n}\n\nexport function changedAttributes(model: ModelMetadata, record: GadgetRecord<RecordData>): Record<string, any> {\n  const changes = record.changes();\n  const attributes = Object.keys(changes).reduce((attrs, key) => {\n    attrs[key] = record[key];\n    return attrs;\n  }, {} as any);\n  return writableAttributes(model, attributes);\n}\n\nexport const getModelByApiIdentifier = (apiIdentifier: string): ModelMetadata => {\n  const typename = modelListIndex[`api:${apiIdentifier}`];\n  if (!typename) {\n    throw new InternalError(`Model ${apiIdentifier} not found in available model metadata`, {\n      availableApiIdentifiers: Object.keys(modelListIndex),\n    });\n  }\n\n  return getModelByTypename(typename);\n};\n\nexport const getModelByTypename = (typename: string): ModelMetadata => {\n  if (!typename) {\n    throw new InternalError(`No typename found on record, __typename must be set for accessing model metadata`);\n  }\n\n  const model = modelsMap[typename];\n  if (!model) {\n    throw new InternalError(`Model with typename ${typename} not found in available model metadata`, {\n      availableTypenames: Object.keys(modelsMap),\n    });\n  }\n\n  return model;\n};\n\nexport enum FieldType {\n  ID = \"ID\",\n  Number = \"Number\",\n  String = \"String\",\n  Enum = \"Enum\",\n  RichText = \"RichText\",\n  DateTime = \"DateTime\",\n  Email = \"Email\",\n  URL = \"URL\",\n  Money = \"Money\",\n  File = \"File\",\n  Color = \"Color\",\n  Password = \"Password\",\n  Computed = \"Computed\",\n  HasManyThrough = \"HasManyThrough\",\n  BelongsTo = \"BelongsTo\",\n  HasMany = \"HasMany\",\n  HasOne = \"HasOne\",\n  Boolean = \"Boolean\",\n  Model = \"Model\",\n  Object = \"Object\",\n  Array = \"Array\",\n  JSON = \"JSON\",\n  Code = \"Code\",\n  EncryptedString = \"EncryptedString\",\n  Vector = \"Vector\",\n  /**\n   * Any value at all.\n   * Prefer FieldType.JSON where possible, it's more descriptive.\n   */\n  Any = \"Any\",\n  Null = \"Null\",\n  RecordState = \"RecordState\",\n  RoleAssignments = \"RoleAssignments\",\n}\n"],
  "mappings": "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",
  "names": ["FieldType"]
}
