{
  "version": 3,
  "sources": ["../../src/shopify/effects.ts"],
  "sourcesContent": ["import { GadgetRecord } from \"@gadgetinc/api-client-core\";\nimport {\n  FieldType,\n  LINK_PARAM,\n  getActionContextFromLocalStorage,\n  getCurrentContext,\n  internalModelManagerForModel,\n  maybeGetActionContextFromLocalStorage,\n} from \"../effects\";\nimport { InvalidActionInputError, MisconfiguredActionError, PermissionDeniedError } from \"../errors\";\nimport { Globals } from \"../globals\";\nimport { AppTenancyKey } from \"../tenancy\";\nimport type { AnyParams, FieldMetadata, ModelDescriptor } from \"../types\";\nimport { assert } from \"../utils\";\n\nexport const ShopifyShopState = {\n  Installed: { created: \"installed\" },\n  Uninstalled: { created: \"uninstalled\" },\n};\n\nexport const ShopifySyncState = {\n  Created: \"created\",\n  Running: \"running\",\n  Completed: \"completed\",\n  Errored: \"errored\",\n};\n\nexport const ShopifyBulkOperationState = {\n  Created: \"created\",\n  Completed: \"completed\",\n  Canceled: \"canceled\",\n  Failed: \"failed\",\n  Expired: \"expired\",\n};\n\nexport const ShopifySellingPlanGroupProductVariantState = {\n  Started: \"started\",\n  Created: \"created\",\n  Deleted: \"deleted\",\n};\n\nexport const ShopifySellingPlanGroupProductState = {\n  Started: \"started\",\n  Created: \"created\",\n  Deleted: \"deleted\",\n};\n\n/**\n * The following is used to power shopifySync model.\n * Learn more about syncing visit our docs: https://docs.gadget.dev/guides/plugins/shopify/syncing-shopify-data#syncing\n */\nexport async function shopifySync(params: AnyParams, record: GadgetRecord<any>): Promise<void> {\n  const context = getActionContextFromLocalStorage();\n  const effectAPIs = context.effectAPIs;\n\n  const syncRecord: { syncSince?: Date; id: bigint; shopId: string; models: any; force: boolean } = assert(\n    record,\n    \"cannot start a shop sync from this action\"\n  );\n\n  const shopId = assert(syncRecord.shopId, \"a shop is required to start a sync\");\n\n  if (!syncRecord.models || (Array.isArray(syncRecord.models) && syncRecord.models.every((m) => typeof m == \"string\"))) {\n    try {\n      await effectAPIs.sync(\n        syncRecord.id.toString(),\n        shopId,\n        syncRecord.syncSince,\n        syncRecord.models,\n        syncRecord.force,\n        params.startReason\n      );\n    } catch (error) {\n      Globals.logger.error({ error, connectionSyncId: syncRecord.id }, \"an error occurred starting shop sync\");\n      throw error;\n    }\n  } else {\n    throw new InvalidActionInputError(\"Models must be an array of api identifiers\");\n  }\n}\n\nexport async function abortSync(params: AnyParams, record: GadgetRecord<any>): Promise<void> {\n  const context = getActionContextFromLocalStorage();\n  const effectAPIs = context.effectAPIs;\n\n  const syncRecord: { id: bigint } = assert(record, \"a record is required to abort a shop sync\");\n\n  const syncId = assert(syncRecord.id, \"a sync id is required to start a sync\");\n\n  if (!params.errorMessage) {\n    record.errorMessage = \"Sync aborted\";\n  }\n\n  Globals.logger.info({ userVisible: true, connectionSyncId: syncId }, \"aborting sync\");\n\n  try {\n    await effectAPIs.abortSync(syncId.toString());\n  } catch (error) {\n    Globals.logger.error({ error, connectionSyncId: syncId }, \"an error occurred aborting sync\");\n    throw error;\n  }\n}\n\n/**\n * Applicable for multi-tenant Shopify apps(public apps), or Shopify Customer Extension apps\n * Enforces that the given record is only accessible by the current shop or customer\n *\n * For new records: sets the the current session's `shopId` to the record. If the tenant is a customer then will set the current sessions' customerId to the record.\n * For existing records: Verifies the record objects `shopId` and/or `customerId` matches the one from the current session.\n *\n * *\n * @param params - incoming data validated against the current `shopId`\n * @param record - record used to validate or set the `shopId` on\n * @param {Object} options - Additional options for cross-shop or cross-customer validation\n * @param {string} options.shopBelongsToField - Specifies which related model is used for cross-shop validation.\n * @param {string} options.customerBelongsToField - Specifies which related model is used for cross-customer validation.\n * @param {boolean} options.enforceCustomerTenancy - Whether or not to enforce customer tenacy. Defaults to true.\n */\nexport async function preventCrossShopDataAccess(\n  params: AnyParams,\n  record: GadgetRecord<any>,\n  options?: { shopBelongsToField?: string; customerBelongsToField?: string; enforceCustomerTenancy?: boolean }\n): Promise<void> {\n  const enforceCustomerTenancy = options?.enforceCustomerTenancy ?? true;\n  const context = getActionContextFromLocalStorage();\n\n  if (context.type != \"effect\") {\n    throw new Error(\"Can't prevent cross shop data access outside of an action effect\");\n  }\n  if (!params) {\n    throw new Error(\n      \"The `params` parameter is required in preventCrossShopDataAccess(params, record, options?: { shopBelongsToField: string })\"\n    );\n  }\n  if (!record) {\n    throw new Error(\n      \"The `record` parameter is required in preventCrossShopDataAccess(params, record, options?: { shopBelongsToField: string })\"\n    );\n  }\n  const model = context.model;\n  const appTenancy = context[AppTenancyKey];\n  const shopBelongsToField = options?.shopBelongsToField;\n  const customerBelongsToField = options?.customerBelongsToField;\n\n  // if there's no tenancy let's continue\n  if (appTenancy?.shopify?.shopId === undefined) {\n    return;\n  }\n  // if this effect is not run in the context of a model then it does not apply\n  if (!model) {\n    return;\n  }\n\n  const shopId = String(appTenancy.shopify.shopId);\n  const customerId = appTenancy.shopify.customerId ? String(appTenancy.shopify.customerId) : undefined;\n\n  const input = params[model.apiIdentifier];\n  validateBelongsToLink(input, record, params, shopId, model, ShopifyShopKey, shopBelongsToField, TenantType.Shop);\n\n  if (customerId && enforceCustomerTenancy) {\n    validateBelongsToLink(input, record, params, customerId, model, ShopifyCustomerKey, customerBelongsToField, TenantType.Customer);\n  }\n}\n\nconst validateBelongsToLink = (\n  input: any,\n  record: any,\n  params: AnyParams,\n  tenantId: string,\n  model: ModelDescriptor,\n  relatedModelKey: string,\n  tenantBelongsToField: string | undefined,\n  tenantType: TenantType\n) => {\n  if (relatedModelKey != ShopifyShopKey && relatedModelKey != ShopifyCustomerKey) {\n    throw new Error(\"Validation for tenancy can only be for Shopify Shop or Shopify Customer models\");\n  }\n  // If this effect is being added to the related tenant model (Shopify Shop or Shopify Customer), simply compare the record's ID\n  if (model.key == relatedModelKey) {\n    if (record && String(record.id) !== tenantId) {\n      throw new PermissionDeniedError();\n    }\n    return;\n  }\n\n  const fieldsIsBelongsToRelatedModel = Object.values(model.fields).filter(\n    (f) => f.fieldType === (FieldType.BelongsTo as string) && f.configuration.relatedModelKey === relatedModelKey\n  );\n\n  if (fieldsIsBelongsToRelatedModel.length === 0) {\n    throw new MisconfiguredActionError(`This model is missing a related ${tenantType} field.`);\n  }\n\n  if (fieldsIsBelongsToRelatedModel.length > 1 && !tenantBelongsToField) {\n    throw new MisconfiguredActionError(\n      `This function is missing a related ${tenantType} field option. \\`${tenantType}BelongsToField\\` is a required option parameter if the model has more than one related ${tenantType} field.`\n    );\n  }\n  let relatedTenantField = fieldsIsBelongsToRelatedModel[0];\n\n  if (tenantBelongsToField) {\n    const selectedField = Object.values(model.fields).find((f) => f.apiIdentifier === tenantBelongsToField);\n    if (!selectedField) {\n      throw new MisconfiguredActionError(`The selected ${tenantType} relation field does not exist.`);\n    }\n\n    if (selectedField.fieldType !== (FieldType.BelongsTo as string) || selectedField.configuration.relatedModelKey !== relatedModelKey) {\n      throw new MisconfiguredActionError(\n        `The selected ${tenantType} relation field should be a \\`Belongs To\\` relationship to the \\`Shopify ${Globals.platformModules\n          .lodash()\n          .capitalize(tenantType)}\\` model.`\n      );\n    } else {\n      relatedTenantField = selectedField;\n    }\n  }\n\n  setBelongsToLink(input, record, params, model, relatedTenantField, tenantId);\n};\n\nconst setBelongsToLink = (\n  input: any,\n  record: any,\n  params: AnyParams,\n  model: ModelDescriptor,\n  relatedField: FieldMetadata,\n  tenantId: string\n) => {\n  // if we're trying to set the params to a shop other than the tenant we should reject\n  if (Globals.platformModules.lodash().isObjectLike(input)) {\n    const objectInput = input as Record<string, any>;\n    if (objectInput[relatedField.apiIdentifier]) {\n      if (String(objectInput[relatedField.apiIdentifier][LINK_PARAM]) !== tenantId) {\n        throw new PermissionDeniedError();\n      }\n    } else {\n      objectInput[relatedField.apiIdentifier] = {\n        [LINK_PARAM]: tenantId,\n      };\n    }\n  } else {\n    params[model.apiIdentifier] = {\n      [relatedField.apiIdentifier]: {\n        [LINK_PARAM]: tenantId,\n      },\n    };\n  }\n\n  if (record) {\n    const value = record.getField(relatedField.apiIdentifier);\n    // if the record doesn't have a shop set then anyone can update it\n    if (value) {\n      const recordShopId = typeof value === \"object\" ? value[LINK_PARAM] : value;\n      if (String(recordShopId) !== tenantId) {\n        throw new PermissionDeniedError();\n      }\n    } else {\n      // we have to re-apply the params to the record to ensure that this still works correctly if it occurs after \"applyParams\"\n      record.setField(relatedField.apiIdentifier, {\n        [LINK_PARAM]: tenantId,\n      });\n    }\n  }\n};\n\n/**\n * Syncs Shopify models across all models\n *\n * @param params - list of Shopify app credentials to sync data from\n * @param syncSince - starting point for data sync (default: all time)\n * @param models - list of model names to sync data from\n * @param force - enforces syncswithout checking if they're up to date\n * @param startReason - a string reason stored on the created 'shopifySync' records\n */\nexport async function globalShopifySync(params: {\n  apiKeys: string[];\n  syncSince: string;\n  models: string[];\n  force: boolean;\n  startReason: string;\n}): Promise<void> {\n  const context = maybeGetActionContextFromLocalStorage();\n  const effectAPIs = assert(\n    context ? context.effectAPIs : getCurrentContext().effectAPIs,\n    \"effect apis is missing from the current context\"\n  );\n  const api = assert(context ? context.api : getCurrentContext().api, \"api client is missing from the current context\");\n\n  const { apiKeys, syncSince, models, force, startReason } = params;\n\n  const {\n    shopModelIdentifier,\n    installedViaKeyFieldIdentifier,\n    shopifySyncModelApiIdentifier,\n    runShopifySyncAction,\n    accessTokenIdentifier,\n    forceFieldIdentifier,\n  } = await effectAPIs.getSyncIdentifiers();\n  const manager = internalModelManagerForModel(api, shopModelIdentifier, []);\n\n  const pageSize = 250;\n  let pageInfo: { first?: number; endCursor?: string; hasNextPage: boolean } = { first: pageSize, hasNextPage: true };\n  const results: { id: string; domain: string; state: Record<string, any>; [key: string]: any }[] = [];\n\n  if (apiKeys && apiKeys.length > 0) {\n    try {\n      while (pageInfo.hasNextPage) {\n        const records = await manager.findMany({\n          filter: {\n            [installedViaKeyFieldIdentifier]: {\n              in: apiKeys,\n            },\n            state: {\n              inState: \"created.installed\",\n            },\n            planName: {\n              notIn: [\"frozen\", \"fraudulent\", \"cancelled\"],\n            },\n          },\n          first: pageInfo.first,\n          after: pageInfo.endCursor,\n        });\n        results.push(...(records as any[]));\n        pageInfo = records.pagination.pageInfo;\n      }\n    } catch (error) {\n      Globals.logger.info({ userVisible: true, error, apiKeys }, \"could not get shops for all API keys\");\n      throw error;\n    }\n\n    for (const result of results) {\n      // skip the sync if there is no accessToken set or if the state is uninstalled\n      if (Globals.platformModules.lodash().isEmpty(result[accessTokenIdentifier]) || result.state?.created == \"uninstalled\") {\n        Globals.logger.info({ shopId: result.id }, \"skipping sync for shop without access token or is uninstalled\");\n        continue;\n      }\n\n      try {\n        const shopifySyncModelManager = Globals.platformModules.lodash().get(api, runShopifySyncAction.dotNotationPath);\n        await shopifySyncModelManager[runShopifySyncAction.apiIdentifier]({\n          [shopifySyncModelApiIdentifier]: {\n            shop: {\n              _link: result.id,\n            },\n            domain: result.domain,\n            syncSince,\n            models,\n            ...(forceFieldIdentifier ? { force } : undefined),\n          },\n          startReason,\n        });\n      } catch (error) {\n        // log that the sync could not be started for the shop but continue\n        Globals.logger.warn({ userVisible: true, error, shop: result }, \"couldn't start sync for shop\");\n      }\n    }\n  } else {\n    throw new InvalidActionInputError(\"missing at least 1 api key\");\n  }\n}\n\nconst enum TenantType {\n  Shop = \"shop\",\n  Customer = \"customer\",\n}\n\nconst shopifyModelKey = (modelName: string): string => {\n  const modelKey = modelName.replaceAll(\" \", \"\");\n  return `DataModel-Shopify-${modelKey}`;\n};\n\n/**\n * Updates the state of a `bulkOperation` record from Shopify when the operation completes.\n *\n * @param record - the `bulkOperation` record updated\n */\nexport async function finishBulkOperation(record: GadgetRecord<any>): Promise<void> {\n  if (!record?.id) {\n    Globals.logger.warn(`Expected bulk operation record to be present for action`);\n    return;\n  }\n\n  const context = getActionContextFromLocalStorage();\n  const shopifyAPI = await (context.connections as Record<string, any>).shopify.forShopId(record.shopId);\n  if (!shopifyAPI) {\n    Globals.logger.error(`Could not instantiate Shopify client for shop ID ${record.shopId}`);\n    return;\n  }\n  const bulkOperation = (\n    await shopifyAPI.graphql(`query {\n        node(id: \"${ShopifyBulkOperationGIDForId(record.id)}\") {\n          ... on BulkOperation {\n            id\n            status\n            errorCode\n            createdAt\n            completedAt\n            objectCount\n            fileSize\n            url\n            type\n            partialDataUrl\n            rootObjectCount\n          }\n        }\n      }`)\n  ).node;\n  // normalize the mixed upper/lowercase (GraphQL/REST) to lowercase\n  const { status, errorCode, type } = bulkOperation;\n  Object.assign(record, {\n    ...bulkOperation,\n    status: status?.toLowerCase(),\n    errorCode: errorCode?.toLowerCase(),\n    type: type?.toLowerCase(),\n    id: record.id,\n  });\n}\n\nconst ShopifyShopKey: string = shopifyModelKey(\"Shop\");\nconst ShopifyCustomerKey: string = shopifyModelKey(\"Customer\");\n\nconst ShopifyBulkOperationGIDForId = (id: string) => `gid://shopify/BulkOperation/${id}`;\n"],
  "mappings": "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",
  "names": ["TenantType"]
}
