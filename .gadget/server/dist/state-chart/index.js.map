{
  "version": 3,
  "sources": ["../../src/state-chart/index.ts"],
  "sourcesContent": ["import { NoTransitionError } from \"../errors\";\nimport { Globals } from \"../globals\";\nimport type { StateData, StateHistoryValue, StateMapper, StateValue } from \"./StateMapper\";\nimport { flattenStateValue } from \"./StateMapper\";\n\ntype ActionContext = any;\n/**\n * Get the states we could potentially transition from given the initial state.\n *\n * Based on the state value, we have many possible states that could receive the incoming actions. For example, with the state value\n *\n *     { \"created\": { \"unfulfilled\": \"needsReview\" } } }\n *\n * we can run actions on three possible states: \"created\", \"created.unfulfilled\", and \"created.unfulfilled.needsReview\". We flatten\n * this state value into the set of state keys for each of these to create the possible transition state.\n */\n\nexport const possibleTransitionStates = ({ record, model }: ActionContext, mapper: StateMapper): StateData[] => {\n  const state = record.state;\n  if (state) {\n    const stateValue = mapper.mapApiIdentifiersToStorageValue(state);\n    return Globals.platformModules.lodash().map(flattenStateValue(stateValue), (key: string) => mapper.stateKeyToData(key));\n  } else if (model.stateChart.initialChildStateKey) {\n    const startState = mapper.stateKeyToData(model.stateChart.initialChildStateKey);\n    return [startState];\n  }\n  return [];\n};\n\n/**\n * Check if we can execute the action.\n *\n * A transition can be taken if there is a possible transition state that has the same from key as the transition we'd like to take.\n *\n * @throws {NoTransitionError} if none of the possible transition states\n */\nexport const checkCanExecute = (context: ActionContext, mapper: StateMapper): void => {\n  const receivingState = Globals.platformModules\n    .lodash()\n    .find(possibleTransitionStates(context, mapper), [\"blob.key\", context.transition.fromStateKey]);\n  if (!receivingState) {\n    const {\n      record: { state },\n    } = context;\n\n    let stateName = \"<unknown>\";\n    if (Globals.platformModules.lodash().isString(state)) {\n      stateName = state;\n    } else if (Globals.platformModules.lodash().isObjectLike(state)) {\n      stateName = JSON.stringify(state);\n    } else if (context.model.stateChart.initialChildStateKey) {\n      const initialStateKey = context.model.stateChart.initialChildStateKey;\n      const state = Globals.platformModules.lodash().find(context.model.stateChart.childStates, { key: initialStateKey });\n      if (state) {\n        stateName = state.name;\n      }\n    }\n\n    let errorMessage = `Invalid action for the ${context.model.apiIdentifier} model. Unable to execute the \"${context.action.apiIdentifier}\" action in state \"${stateName}\".`;\n    if (context.action.apiIdentifier == \"logInViaEmail\") {\n      errorMessage = `Invalid action for the ${context.model.apiIdentifier} model. This session is already logged in for ${context.params.email}.`;\n    }\n    throw new NoTransitionError(errorMessage);\n  }\n};\n\n/**\n * Incorporate a given state value into an existing historical state.\n *\n * For example, if we have the following history and state:\n *\n * ```js\n * const history = {\n *   current: \"created\",\n *   children: {\n *     created: {\n *       current: \"unfulfilled\"\n *     },\n *     archived: {\n *       current: \"softDeleted\"\n *     }\n *   }\n * };\n *\n * const state = { created: \"fulfilled\" };\n * ```\n *\n * the new historical state would be\n *\n * ```js\n * const history = {\n *   current: \"created\",\n *   children: {\n *     created: {\n *       current: \"fulfilled\"\n *     },\n *     archived: {\n *       current: \"softDeleted\"\n *     }\n *   }\n * };\n * ```\n *\n * Semantically, we set the value of \"current\" (in the history) at every point along the state value \"path\".\n */\nexport const computeStateHistory = (history: StateHistoryValue, state: StateValue): StateHistoryValue => {\n  const newHistory: StateHistoryValue = history ? Globals.platformModules.lodash().cloneDeep(history) : { current: \"\" };\n  const path = [];\n  while (Globals.platformModules.lodash().isObject(state)) {\n    const [current, newState] = Object.entries(state)[0];\n\n    path.push(\"current\");\n    Globals.platformModules.lodash().set(newHistory, path, current);\n    path.pop();\n\n    path.push(\"children\");\n    path.push(current);\n\n    state = newState;\n  }\n\n  path.push(\"current\");\n  Globals.platformModules.lodash().set(newHistory, path, state);\n\n  return newHistory;\n};\n\n/**\n * Find the state value for the state we'll be transitioning into.\n *\n * For states without children, the state value will just be the state we're transitioning to.\n *\n * For states with children, we need to restore the child state from history. A historical value is used if:\n * 1. there actually is a historical value (in other words, is not `undefined`),\n * 2. the state requests history to be restored, and\n * 3. the historical value is for a nested state that actually exists.\n *\n * We recursively repeat the above. Once finished, if we're still at a state that has children, we go as deep as possible using the\n * child states that are configured to be the initial.\n */\nexport const computeStateValueFor = (history: StateHistoryValue, state: StateData, mapper: StateMapper): StateValue => {\n  // This will be the \"path\" to the penultimate state in the state value we return. For example, if the state value we\n  // return is `{ a: { b: \"c\" } }`, the path will be `[\"a\", \"b\"]`.\n  const path = Globals.platformModules.lodash().clone(state.path);\n\n  // A path to dig into the historical value. The historical value nests every state under \"children\", hence the `flatMap`.\n  const historyPath = path.flatMap((segment: string) => [\"children\", segment]);\n\n  while (state.blob.initialChildStateKey) {\n    // Rule (2) above\n    if (state.blob.restoreHistory) {\n      // The value we potentially want to restore is under the \"current\" key in the history value, so temporarily push \"current\" into the\n      // path so we can grab it, but pop it again because we may recurse further.\n      historyPath.push(\"current\");\n      const apiIdentifier = Globals.platformModules.lodash().get(history, historyPath) as string;\n      historyPath.pop();\n\n      // Rules (1) and (3) above. If there's no historical value, the `get` above will return undefined, and no child state should\n      // have an undefined API identifier, so we'll hit the break below.\n      const maybeChildState = Globals.platformModules.lodash().find(state.blob.childStates, { apiIdentifier });\n      if (maybeChildState) {\n        historyPath.push(\"children\");\n        historyPath.push(apiIdentifier);\n        path.push(apiIdentifier);\n        state = mapper.stateKeyToData(maybeChildState.key);\n        continue;\n      }\n    }\n\n    break;\n  }\n\n  path.pop();\n\n  // Now that we've went as deep into history as possible, initial the rest of the nested states with the initial states\n  while (state.blob.initialChildStateKey) {\n    path.push(state.blob.apiIdentifier);\n    state = mapper.stateKeyToData(state.blob.initialChildStateKey);\n  }\n\n  // Special case for a root state, just return the API identifier. For example, if the created state has no nested states, the\n  // actual state value will be `\"created\"`, not `{ created: ??? }`.\n  if (Globals.platformModules.lodash().isEmpty(path)) {\n    return state.apiIdentifier;\n  }\n\n  // `set` will ensure all intermediate objects are initialized. So `set({}, ['a', 'b'], 'c')` will give us `{ a: { b: \"c\" } }`\n  return Globals.platformModules.lodash().set({}, path, state.apiIdentifier);\n};\n\nexport const _doStateTransition = (\n  currentHistory: StateHistoryValue,\n  currentState: StateValue,\n  toState: StateData,\n  mapper: StateMapper,\n  record: any\n): { newState: StateValue; newHistory: StateHistoryValue } => {\n  const newHistory = computeStateHistory(currentHistory, currentState);\n\n  // It's important that we use the new history value here, instead of `recordStateHistory`, in case of a self transition. The historical\n  // value contains the position we were in _previously_. That means that if we did a self transition, we'd revert to the previous state\n  // (if it were different than the current state).\n  const newState = computeStateValueFor(newHistory, toState, mapper);\n\n  record.state = newState;\n  record.stateHistory = newHistory;\n  return { newState, newHistory };\n};\n\nexport const doStateTransition = (context: ActionContext, mapper: StateMapper): { newState: StateValue; newHistory: StateHistoryValue } => {\n  const toState = mapper.stateKeyToData(context.transition.toStateKey);\n  const currentState = Globals.platformModules.lodash().cloneDeep(context.record.state);\n  const currentHistory = Globals.platformModules.lodash().cloneDeep(context.record.stateHistory);\n\n  return _doStateTransition(currentHistory, currentState, toState, mapper, context.record);\n};\n\n// In case the state still hasn't been persisted, ensure the state change still happens\nexport const persistStateTransition = async (\n  newState: StateValue,\n  newHistory: StateHistoryValue,\n  context: ActionContext\n): Promise<void> => {\n  if (context.record.changed(\"state\") || context.record.changed(\"stateHistory\")) {\n    await updateState(context, newState, newHistory);\n  }\n};\n\n/** Persist the new state into the model record */\nexport const updateState = async (\n  { api, model, record, scope, logger }: ActionContext,\n  newState: StateValue,\n  stateHistory: StateHistoryValue\n): Promise<void> => {\n  if (record.id && !scope.recordDeleted) {\n    await api.internal[model.apiIdentifier].update(record.id, { [model.apiIdentifier]: { state: newState, stateHistory } });\n    logger.debug(\"updated record state\");\n  }\n};\n\nexport { isStateHistoryValue, isStateValue, StateMapper } from \"./StateMapper\";\nexport type { StateHistoryValue, StateValue, StateValueMap } from \"./StateMapper\";\n"],
  "mappings": "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",
  "names": ["import_StateMapper", "state"]
}
