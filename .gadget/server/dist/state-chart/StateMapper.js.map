{
  "version": 3,
  "sources": ["../../src/state-chart/StateMapper.ts"],
  "sourcesContent": ["import mapValue, { assert, invert, isEmpty, isObject, isString } from \"../utils\";\n\nexport type StateValueMap = {\n  [key: string]: StateValue;\n};\n\ntype ModelBlob = any;\nexport type StateBlob = any;\n\n/**\n * The value representing a state.\n *\n * For example,\n *\n * - `\"created\"`, for simple states;\n * - `{ \"created\": \"unfulfilled\" }`, for compound states; and\n * - `{ \"created\": { \"fulfilled\": \"no\", \"reviewed\": \"no } } }`, for parallel states.\n */\nexport type StateValue = string | StateValueMap;\n\n/**\n * A value storing the historical state values.\n *\n * For example,\n *\n * ```js\n * {\n *   current: \"created\",\n *   children: {\n *     created: {\n *       current: \"fulfilled\",\n *     },\n *     archive: {\n *       current: \"softDeleted\",\n *     },\n *   }\n * }\n * ```\n */\nexport type StateHistoryValue = {\n  /** The name of the state that was previously active */\n  current: string;\n\n  /** Historical values of all nested states */\n  children?: Record<string, StateHistoryValue>;\n};\n\n/** Data about a state, as returned by lookup by state key via `StateMapper` */\nexport type StateData = {\n  /** The state value for a given state, as we'd persist it in the DB */\n  value: StateValue;\n\n  /** The API identifier for the state (can be changed by the user) */\n  apiIdentifier: string;\n\n  /** The `StateBlob` this state was derived from, as given to the app sandbox */\n  blob: StateBlob;\n\n  /** A path to key to this state from the root, useful with lodash's get/set */\n  path: string[];\n};\n\n/** Deeply map the keys/values of a state value */\nfunction mapStateValue(state: StateValue, mapper: (key: string) => string): StateValue {\n  if (isObject(state)) {\n    const result: StateValueMap = {};\n    for (const [key, value] of Object.entries(state)) {\n      result[mapper(key)] = mapStateValue(value, mapper);\n    }\n    return result;\n  }\n\n  return mapper(state);\n}\n\n/** Deeply map the keys/values of a state history value */\nfunction mapStateHistoryValue(state: StateHistoryValue, mapper: (key: string) => string): StateHistoryValue {\n  const result: StateHistoryValue = {\n    current: mapper(state.current),\n  };\n\n  if (state.children) {\n    result.children = {};\n    for (const [name, history] of Object.entries(state.children)) {\n      result.children[mapper(name)] = mapStateHistoryValue(history, mapper);\n    }\n  }\n\n  return result;\n}\n\n/** Determine if a given value is a state value */\nexport function isStateValue(value: any): value is StateValue {\n  if (isString(value)) {\n    return true;\n  }\n\n  if (!isObject(value)) {\n    return false;\n  }\n\n  return Object.entries(value).every(([key, value]) => isString(key) && isStateValue(value));\n}\n\n/** Determine if a given value is a state history value */\nexport function isStateHistoryValue(value: any): value is StateHistoryValue {\n  if (!isObject(value)) {\n    return false;\n  }\n\n  const record = value as Record<string, any>;\n  if (!(\"current\" in record) || !isString(record.current)) {\n    return false;\n  }\n\n  if (\"children\" in record && record.children) {\n    if (!isObject(record.children)) {\n      return false;\n    }\n\n    return Object.values(record.children).every((v) => isStateHistoryValue(v));\n  }\n\n  return true;\n}\n\n/**\n * Map state keys to data on those states.\n *\n * The things in the state chart are deeply nested, so the `StateMapper` takes care of flattening this structure into an efficient lookup\n * table, based on the state keys.\n *\n * `StateMapper` also exposes functions to map back and forth between transit state values (using the API identifiers) and storage state\n * values (using state keys).\n */\nexport class StateMapper {\n  stateKeyToDataMap: { [key: string]: StateData } = {};\n\n  constructor(readonly model: ModelBlob) {\n    this.populateStateMaps(model.stateChart.childStates, []);\n  }\n\n  mapStorageValueToApiIdentifiers(stateValue: StateValue): StateValue {\n    return mapStateValue(stateValue, (key: string) => {\n      if (key in this.stateKeyToDataMap) {\n        return this.stateKeyToDataMap[key].apiIdentifier;\n      }\n      return key;\n    });\n  }\n\n  mapApiIdentifiersToStorageValue(stateValue: StateValue): StateValue {\n    return mapStateValue(stateValue, (apiIdentifier: string) => {\n      if (apiIdentifier in this.apiIdentifierToStateKeyMap) {\n        return this.apiIdentifierToStateKeyMap[apiIdentifier];\n      }\n      return apiIdentifier;\n    });\n  }\n\n  mapStorageHistoryValueToApiIdentifiers(stateHistoryValue: StateHistoryValue): StateHistoryValue {\n    return mapStateHistoryValue(stateHistoryValue, (key: string) => {\n      if (key in this.stateKeyToDataMap) {\n        return this.stateKeyToDataMap[key].apiIdentifier;\n      }\n      return key;\n    });\n  }\n\n  mapApiIdentifiersToStorageHistoryValue(stateHistoryValue: StateHistoryValue): StateHistoryValue {\n    return mapStateHistoryValue(stateHistoryValue, (apiIdentifier: string) => {\n      if (apiIdentifier in this.apiIdentifierToStateKeyMap) {\n        return this.apiIdentifierToStateKeyMap[apiIdentifier];\n      }\n      return apiIdentifier;\n    });\n  }\n\n  public stateKeyToData(stateKey: string): StateData {\n    return assert(this.stateKeyToDataMap[stateKey], `state key \"${stateKey}\" not found in state map`);\n  }\n\n  public get apiIdentifierToStateKeyMap(): Record<string, string> {\n    return invert(mapValue(this.stateKeyToDataMap, ({ apiIdentifier }: any) => apiIdentifier));\n  }\n\n  public populateStateMaps(states: StateBlob[], path: string[]): void {\n    for (const state of states) {\n      path.push(state.apiIdentifier);\n\n      this.stateKeyToDataMap[state.key] = {\n        apiIdentifier: state.apiIdentifier,\n        blob: state,\n        value: stateValueFromPath(path),\n        path: path.slice(),\n      };\n\n      if (state.childStates) {\n        this.populateStateMaps(state.childStates, path);\n      }\n\n      path.pop();\n    }\n  }\n}\n\n/**\n * Compute a state value, from a \"path\" of identifiers.\n *\n * **NOTE**: State values are persisted, so bear that in mind when changing the shape.\n */\nexport function stateValueFromPath(path: string[]): StateValue {\n  if (path.length == 0) {\n    // Note, we're not throwing a special error here because we're in control of the code that calls this method, and should always pass in a non-empty path\n    throw new Error(\"can't compute state value from an empty path\");\n  }\n\n  if (path.length == 1) {\n    return path[0];\n  }\n\n  let index = path.length - 1;\n  let stateValue: StateValue = path[index];\n  while (--index >= 0) {\n    const stateApiIdentifier = path[index];\n    stateValue = { [stateApiIdentifier]: stateValue };\n  }\n  return stateValue;\n}\n\n/**\n * Flatten a state value.\n *\n * For example,\n *\n * ```json\n * { \"created\": { \"unfulfilled\": \"needsReview\" } } }\n * ```\n *\n * will be flattened into `[\"created\", \"unfulfilled\", \"needsReview\"]`\n */\nexport function flattenStateValue(state: StateValue): string[] {\n  if (isString(state)) {\n    return [state];\n  }\n\n  if (isEmpty(state)) {\n    return [];\n  }\n\n  const [key, stateValue] = Object.entries(state)[0];\n  return [key, ...flattenStateValue(stateValue)];\n}\n"],
  "mappings": "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",
  "names": ["value", "mapValue"]
}
